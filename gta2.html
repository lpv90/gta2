<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>GTA 2 Clone - 3D Version</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            color: #fff;
            font-family: Arial, sans-serif;
        }
        canvas { 
            display: block; 
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #fff;
            font-size: 14px;
        }
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        .control-instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: #fff;
        }
    </style>
    
    <!-- Load THREE.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="info">GTA 2 Clone - 3D Version</div>
    <div id="stats">
        Cash: $<span id="cash">0</span><br>
        Health: <span id="health">100</span>%<br>
        Wanted: <span id="wanted">0</span>/6
    </div>
    <div class="control-instructions">
        Controls: WASD or Arrow Keys to move | E to enter/exit vehicles | L to toggle lights | K to toggle day/night | SPACE for handbrake/shooting
    </div>
    
    <script>
        // Utility Functions
        function degToRad(degrees) {
            return degrees * (Math.PI / 180);
        }
        
        // Game Class
        class Game {
            constructor() {
                console.log('Game constructor called');
                
                // Initialize the game
                this.init();
            }
            
            init() {
                console.log('Initializing game...');
                
                // Constants
                this.CAMERA_HEIGHT = 40; // Reduced from 80 to 60 (25% closer)
                this.CAMERA_ANGLE = 90; // Changed from 60 to 90 (completely top-down)
                
                // Create scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87ceeb); // Sky blue
                
                // Replace day/night cycle with manual toggle
                this.isDay = true; // Start in daytime
                this.canToggleDayNight = true; // Prevent key spam
                
                // Initialize Web Audio API for game sounds
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.skidSoundPlaying = false;
                this.skidSoundNode = null;
                
                // Create camera (perspective camera for 3D view)
                this.camera = new THREE.PerspectiveCamera(
                    75, window.innerWidth / window.innerHeight, 0.1, 1000
                );
                
                // Set camera position and angle for top-down view (but with perspective)
                this.camera.position.set(0, this.CAMERA_HEIGHT, 0);
                this.camera.rotation.x = degToRad(-this.CAMERA_ANGLE);
                
                // Create renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true; // Enable shadows
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows
                document.body.appendChild(this.renderer.domElement);
                
                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
                
                // Track collidable objects
                this.collidableObjects = [];
                
                // Collision parameters
                this.collisionRadius = 2.5; // Car collision radius
                this.bounceFactor = 0.45; // Reduced from 0.65 to make bounces less extreme
                this.sparkDuration = 500; // How long sparks last in milliseconds
                this.currentSparks = []; // Array to hold active spark effects
                this.lastCollisionTime = 0; // To prevent multiple collisions in quick succession
                this.collisionCooldown = 150; // Reduced from 200ms to allow quicker collision detection for safety
                this.lastCollisionNormal = null; // To track the normal of the last collision
                
                // Bullet parameters
                this.bullets = []; // Array to hold active bullets
                this.bulletSpeed = 120; // Increased bullet speed for Uzi (was 80)
                this.bulletLifetime = 1500; // Reduced bullet lifetime for Uzi (was 2000)
                this.canShoot = true; // Can shoot flag
                this.bulletCount = 0; // Counter for bullets fired (for tracer rounds)
                this.tracerInterval = 4; // Show tracer every 4 bullets
                
                // Lighting state
                this.lightsOn = false;
                this.headlights = []; // Will store headlight objects
                this.taillights = []; // Will store taillight objects
                this.canToggleLights = true; // Prevent light toggle spam
                
                // Collision recovery variables
                this.inCollisionRecovery = false;
                this.collisionTargetPosition = new THREE.Vector3();
                this.collisionRepositionSpeed = 0;
                this.collisionStartPosition = new THREE.Vector3();
                this.collisionProgress = 0;
                
                // Car physics variables for improved driving model
                this.handbrakeActive = false; // Handbrake state
                this.rearTractionFactor = 1.0; // Full traction by default
                this.lateralVelocity = 0; // Side-slip velocity
                this.angularVelocity = 0; // Rotation speed
                this.driftAngle = 0; // Visual drift angle for car body
                this.wheelBase = 3.0; // Distance between front and rear wheels
                this.turnRadius = 6.0; // Turning radius at low speed
                
                // Skidmark system
                this.skidmarks = []; // Array to store skidmark meshes
                this.maxSkidmarks = 150; // Increased slightly to account for two tracks
                this.lastSkidmarkTime = 0; // To control skidmark frequency
                this.lastWheelPositions = {
                    leftRear: new THREE.Vector3(),
                    rightRear: new THREE.Vector3()
                }; // Track previous wheel positions
                this.minSegmentLength = 0.5; // Minimum length for a skidmark segment
                this.skidmarkMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000, // Pure black
                    transparent: true,
                    opacity: 0.95,
                    depthWrite: false
                });
                this.activeSkidmarks = false; // Track if skidmarks are currently being created
                
                // Sound settings for skidmarks
                this.skidSoundVolume = 0.4; // Volume for skid sound
                
                // Create game objects
                this.createWorld();
                
                // Initialize player movement variables
                this.playerMaxSpeed = 80; // Increased from 30 to 50 for higher top speed
                this.playerAcceleration = 35; // Reduced from 20 to 15 for more gradual acceleration
                this.playerDeceleration = 60; // Reduced from 15 to 10 for less responsive braking
                this.playerFriction = 8; // Reduced from 10 to 5 for longer coasting/sliding
                this.playerRotationSpeed = 1.8; // Slightly reduced for more realistic turning
                this.playerVelocity = 0; // current velocity
                this.playerDirection = new THREE.Vector2(0, 0); // movement direction vector
                
                // Initialize player state
                this.isInVehicle = true; // Start in vehicle
                this.canToggleVehicle = true; // Prevent spamming E key
                this.lastVehiclePosition = new THREE.Vector3(); // Store vehicle position when exiting
                this.lastVehicleRotation = 0; // Store vehicle rotation when exiting
                
                // Camera transition parameters
                this.targetCameraHeight = this.CAMERA_HEIGHT; // Target for smooth transitions
                this.cameraTransitionSpeed = 10; // Speed of camera height transitions
                
                // Collision rotation transition parameters
                this.inRotationTransition = false;
                this.targetRotation = 0;
                this.rotationSpeed = 0;
                
                // Start animation loop
                this.lastTime = Date.now();
                this.animate();
                
                console.log('Game initialized successfully!');
                
                // Initialize keysPressed object to track key states
                this.keysPressed = {};
                
                // Initialize shooting system
                this.initShooting();
                
                // Vehicle damage system
                this.vehicleMaxHealth = 200; // Increased from 100 to 200 HP
                this.vehicleHealth = this.vehicleMaxHealth; // Current health
                this.damagePerBullet = 10; // Damage per bullet hit
                this.vehicleIsExploding = false; // Flag to track explosion state
                this.vehicleCanBeDamaged = true; // Flag to prevent damage during explosion
                
                // Setup UI elements
                this.setupUI();
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            animate() {
                requestAnimationFrame(this.animate.bind(this));
                
                // Calculate delta time
                const currentTime = performance.now();
                const deltaTime = (currentTime - this.lastTime) / 1000; // Convert to seconds
                this.lastTime = currentTime;
                
                // Update game state
                this.updateGame(deltaTime);
                
                // Render the scene
                this.renderer.render(this.scene, this.camera);
            }
            
            updateGame(deltaTime) {
                // Update vehicle or pedestrian position based on keyboard input
                this.handleMovement(deltaTime);
                
                // Handle shooting when player is on foot and space key is pressed
                if (!this.isInVehicle && this.pedestrian && this.keysPressed['Space'] && this.canShoot) {
                    this.shootBullet();
                }
                
                // Update bullets
                if (this.bullets) {
                    this.updateBullets(deltaTime);
                }
                
                // Restore camera functionality
                // Update camera position to follow player (whether in vehicle or pedestrian)
                const target = this.isInVehicle ? this.player : this.pedestrian;
                
                if (target) {
                    // Smoothly interpolate camera height
                    const heightDifference = this.targetCameraHeight - this.camera.position.y;
                    if (Math.abs(heightDifference) > 0.1) {
                        this.camera.position.y += heightDifference * Math.min(1, this.cameraTransitionSpeed * deltaTime);
                    } else {
                        this.camera.position.y = this.targetCameraHeight;
                    }
                    
                    this.camera.position.x = target.position.x;
                    this.camera.position.z = target.position.z;
                    
                    // Always look straight down at the player
                    this.camera.lookAt(
                        target.position.x,
                        target.position.y,
                        target.position.z
                    );
                    
                    // Keep camera rotation values fixed
                    this.camera.rotation.z = 0;
                    this.camera.rotation.x = degToRad(-this.CAMERA_ANGLE);
                }
                
                // Update lighting for day/night cycle
                this.updateLighting(deltaTime);
                
                // Update skidmarks
                this.updateSkidmarks(deltaTime);
                
                // Update UI stats
                document.getElementById('cash').textContent = Math.floor(Math.random() * 100);
            }
            
            createWorld() {
                // Create ground plane with improved material for better light reflection
                const groundSize = 500;
                const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333, // Dark gray for asphalt
                    roughness: 0.8,
                    metalness: 0.2
                });
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = degToRad(-90); // Rotate to be horizontal
                this.ground.position.y = 0;
                this.ground.receiveShadow = true; // Ground can receive shadows
                this.scene.add(this.ground);
                
                // Reset collidable objects array
                this.collidableObjects = [];
                
                // Create city grid
                this.createCityGrid();
                
                // Create player
                this.createPlayerVehicle();
                
                // Add lighting
                this.createLighting();
                
                // Setup keyboard controls
                this.keys = {};
                document.addEventListener('keydown', (e) => this.onKeyDown(e));
                document.addEventListener('keyup', (e) => this.onKeyUp(e));
            }
            
            createLighting() {
                // Add ambient light (general illumination)
                this.ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(this.ambientLight);
                
                // Add directional light (sun-like)
                this.sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
                this.sunLight.position.set(100, 100, 50);
                this.sunLight.castShadow = true;
                
                // Configure shadow properties for better quality
                this.sunLight.shadow.mapSize.width = 2048;
                this.sunLight.shadow.mapSize.height = 2048;
                this.sunLight.shadow.camera.near = 0.5;
                this.sunLight.shadow.camera.far = 500;
                this.sunLight.shadow.camera.left = -100;
                this.sunLight.shadow.camera.right = 100;
                this.sunLight.shadow.camera.top = 100;
                this.sunLight.shadow.camera.bottom = -100;
                
                this.scene.add(this.sunLight);
                
                // Add a subtle blue moon light for night time
                this.moonLight = new THREE.DirectionalLight(0x8888ff, 0);
                this.moonLight.position.set(-100, 100, -50);
                this.scene.add(this.moonLight);
            }
            
            updateLighting(deltaTime) {
                // Adjust lighting based on day/night state instead of time progression
                if (this.isDay) {
                    // Daytime lighting
                    this.sunLight.intensity = 0.8; // Full daylight
                    this.moonLight.intensity = 0; // No moonlight during day
                    this.ambientLight.intensity = 0.5; // Bright ambient light
                    this.scene.background = new THREE.Color(0x87ceeb); // Sky blue
                    
                    // Remove fog or make it minimal during day
                    if (!this.scene.fog) {
                        this.scene.fog = new THREE.Fog(this.scene.background, 10, 100);
                    } else {
                        this.scene.fog.color = this.scene.background;
                        this.scene.fog.far = 100; // Better visibility during day
                    }
                } else {
                    // Nighttime lighting - less dark than before
                    this.sunLight.intensity = 0; // No sunlight at night
                    this.moonLight.intensity = 0.25; // Brighter moonlight (was 0.1-0.2)
                    this.ambientLight.intensity = 0.25; // Increased ambient light (was 0.1)
                    this.scene.background = new THREE.Color(0x0a1a40); // Slightly lighter dark blue (was 0x0a1a2a)
                    
                    // Add fog at night for atmosphere
                    if (!this.scene.fog) {
                        this.scene.fog = new THREE.Fog(this.scene.background, 10, 60);
                    } else {
                        this.scene.fog.color = this.scene.background;
                        this.scene.fog.far = 60; // Reduced visibility at night but not too much
                    }
                    
                    // Auto-toggle headlights at night if they're off
                    if (!this.lightsOn) {
                        this.toggleLights();
                    }
                }
            }
            
            // Add method to toggle between day and night
            toggleDayNight() {
                this.isDay = !this.isDay;
                
                // Update lighting immediately
                this.updateLighting(0);
                
                // Update info text
                document.getElementById('info').textContent = this.isDay ? 
                    "GTA 2 Clone - Daytime (Press K to toggle)" : 
                    "GTA 2 Clone - Nighttime (Press K to toggle)";
            }
            
            onKeyDown(event) {
                this.keys[event.key.toLowerCase()] = true;
                
                // Track the pressed key
                const key = event.code || event.key;
                this.keysPressed[key] = true;
                
                // Handle vehicle entry/exit with E key
                if (event.key.toLowerCase() === 'e' && this.canToggleVehicle) {
                    this.toggleVehicle();
                    // Prevent key spam by adding a cooldown
                    this.canToggleVehicle = false;
                    setTimeout(() => {
                        this.canToggleVehicle = true;
                    }, 500); // 500ms cooldown
                }
                
                // Handle light toggle with L key
                if (event.key.toLowerCase() === 'l' && this.canToggleLights) {
                    this.toggleLights();
                    // Prevent light toggle spam
                    this.canToggleLights = false;
                    setTimeout(() => {
                        this.canToggleLights = true;
                    }, 500); // 500ms cooldown
                }
                
                // Handle day/night toggle with K key
                if (event.key.toLowerCase() === 'k' && this.canToggleDayNight) {
                    this.toggleDayNight();
                    // Prevent toggle spam
                    this.canToggleDayNight = false;
                    setTimeout(() => {
                        this.canToggleDayNight = true;
                    }, 500); // 500ms cooldown
                }
                
                // Handle shooting with mouse click when on foot
                if (event.key === ' ' && !this.isInVehicle && this.canShoot) {
                    this.shootBullet();
                    // Add cooldown for automatic gun
                    this.canShoot = false;
                    setTimeout(() => {
                        this.canShoot = true;
                    }, 85); // 85ms cooldown for Uzi-like fire rate (approx 700 RPM)
                }
                
                // Handle handbrake with SPACE key
                if (event.key === ' ' && this.isInVehicle && !this.handbrakeActive) {
                    this.handbrakeActive = true;
                    
                    // Reset skidmark tracking when handbrake is activated
                    this.lastWheelPositions.leftRear.set(0, 0, 0);
                    this.lastWheelPositions.rightRear.set(0, 0, 0);
                    this.activeSkidmarks = true;
                    
                    // Reduce rear wheel traction when handbrake is active
                    this.rearTractionFactor = 0.02; // Almost no rear traction
                    
                    // Front traction remains high - only rear wheels lose grip
                    this.frontTractionFactor = 0.98; // High front traction maintained
                    
                    // Add some lateral velocity for better drift initiation when turning
                    if (Math.abs(this.playerVelocity) > 5) {
                        const isTurningLeft = this.keys['a'] || this.keys['arrowleft'];
                        const isTurningRight = this.keys['d'] || this.keys['arrowright'];
                        
                        if (isTurningLeft || isTurningRight) {
                            // Add lateral velocity kick in the OPPOSITE direction to the turn
                            // This is crucial - for a left turn, the car should slide right
                            const turnDirection = isTurningLeft ? 1 : -1;
                            
                            // Apply strong outward lateral force (opposite to turn direction)
                            this.lateralVelocity -= turnDirection * Math.abs(this.playerVelocity) * 0.4;
                            
                            // Add a strong angular velocity kick in the TURNING direction
                            // This makes the car rotate/spin in the direction of the turn
                            this.angularVelocity += turnDirection * Math.abs(this.playerVelocity) * 0.03;
                            
                            // Reduce forward velocity to simulate braking effect
                            this.playerVelocity *= 0.85;
                        }
                    }
                    
                    // Play handbrake sound effect
                    this.playHandbrakeSound();
                    
                    // Update info text
                    document.getElementById('info').textContent = "HANDBRAKE ENGAGED";
                    setTimeout(() => {
                        if (this.handbrakeActive) {
                            document.getElementById('info').textContent = "GTA 2 Clone - Drifting";
                        }
                    }, 1000);
                }
            }
            
            onKeyUp(event) {
                this.keys[event.key.toLowerCase()] = false;
                
                // Untrack the released key
                const key = event.code || event.key;
                this.keysPressed[key] = false;
                
                // Handle handbrake release with SPACE key
                if (event.key === ' ' && this.isInVehicle) {
                    this.handbrakeActive = false;
                    this.activeSkidmarks = false;
                    
                    // Reset skidmark tracking when handbrake is released
                    this.lastWheelPositions.leftRear.set(0, 0, 0);
                    this.lastWheelPositions.rightRear.set(0, 0, 0);
                    
                    // Reset traction factors to defaults
                    this.frontTractionFactor = 0.95;
                    
                    // Stop skid sound with fadeout
                    this.stopSkidSound();
                    
                    // Reset info text
                    document.getElementById('info').textContent = "GTA 2 Clone - 3D Version";
                }
            }
            
            playHandbrakeSound() {
                // Only start a new sound if one isn't already playing
                if (!this.skidSoundPlaying) {
                    // Stop any existing sound
                    if (this.skidSoundNode) {
                        this.stopSkidSound();
                    }
                    
                    // Create continuously looping noise for skid sound using Web Audio API
                    this.skidSoundPlaying = true;
                    
                    // Use audio context created during initialization
                    const ctx = this.audioContext;
                    
                    // Create noise source (for tire skid sound)
                    const bufferSize = 2 * ctx.sampleRate;
                    const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                    const data = noiseBuffer.getChannelData(0);
                    
                    // Fill with noise with brown noise characteristics (deeper than white noise)
                    let lastOut = 0;
                    for (let i = 0; i < bufferSize; i++) {
                        // Brown noise algorithm (deeper rumble)
                        const white = Math.random() * 2 - 1;
                        data[i] = (lastOut + (0.02 * white)) / 1.02;
                        lastOut = data[i];
                        data[i] *= 3.5; // Amplify signal
                    }
                    
                    // Create audio source from noise buffer
                    const noise = ctx.createBufferSource();
                    noise.buffer = noiseBuffer;
                    noise.loop = true;
                    
                    // Create bandpass filter to shape noise into tire skid sound
                    const bandpass = ctx.createBiquadFilter();
                    bandpass.type = 'bandpass';
                    bandpass.frequency.value = 2000; // Center frequency
                    bandpass.Q.value = 1.5; // Bandwidth
                    
                    // Create gain node for volume control
                    const gainNode = ctx.createGain();
                    gainNode.gain.value = this.skidSoundVolume;
                    
                    // Connect nodes
                    noise.connect(bandpass);
                    bandpass.connect(gainNode);
                    gainNode.connect(ctx.destination);
                    
                    // Store references to nodes for later manipulation
                    this.skidSoundNode = {
                        source: noise,
                        gain: gainNode,
                        filter: bandpass
                    };
                    
                    // Start playback
                    noise.start();
                }
            }
            
            stopSkidSound() {
                if (this.skidSoundNode) {
                    // Fade out the sound to avoid abrupt stop
                    const fadeOutDuration = 0.3; // seconds
                    const currentTime = this.audioContext.currentTime;
                    
                    this.skidSoundNode.gain.gain.setValueAtTime(
                        this.skidSoundNode.gain.gain.value, 
                        currentTime
                    );
                    this.skidSoundNode.gain.gain.exponentialRampToValueAtTime(
                        0.01, 
                        currentTime + fadeOutDuration
                    );
                    
                    // Schedule actual stop after fade completes
                    setTimeout(() => {
                        if (this.skidSoundNode) {
                            this.skidSoundNode.source.stop();
                            this.skidSoundNode = null;
                            this.skidSoundPlaying = false;
                        }
                    }, fadeOutDuration * 1000);
                }
            }
            
            createNoiseBuffer(audioContext) {
                // Create a buffer of white noise for realistic tire sounds
                const bufferSize = audioContext.sampleRate * 0.5; // 0.5 second buffer
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                // Fill the buffer with noise
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                return buffer;
            }
            
            updatePlayer(deltaTime) {
                if (this.isInVehicle) {
                    this.updateVehicle(deltaTime);
                } else {
                    this.updatePedestrian(deltaTime);
                }
                
                // Update camera position to follow player (whether in vehicle or pedestrian)
                const target = this.isInVehicle ? this.player : this.pedestrian;
                
                if (target) {
                    this.target = target;
                    this.targetPosition = target.position;
                    
                    // Smoothly interpolate camera height
                    const heightDifference = this.targetCameraHeight - this.camera.position.y;
                    if (Math.abs(heightDifference) > 0.1) {
                        this.camera.position.y += heightDifference * Math.min(1, this.cameraTransitionSpeed * deltaTime);
                    } else {
                        this.camera.position.y = this.targetCameraHeight;
                    }
                    
                    this.camera.position.x = target.position.x;
                    this.camera.position.z = target.position.z;
                    
                    // Always look straight down at the player
                    this.camera.lookAt(
                        target.position.x,
                        target.position.y,
                        target.position.z
                    );
                    
                    // Keep camera rotation values fixed
                    this.camera.rotation.z = 0;
                    this.camera.rotation.x = degToRad(-this.CAMERA_ANGLE);
                }
                
                // Update bullets
                this.updateBullets(deltaTime);
            }
            
            updateVehicle(deltaTime) {
                // Forward/backward input
                let moveInput = 0;
                if (this.keys['w'] || this.keys['arrowup']) {
                    moveInput = 1;
                } else if (this.keys['s'] || this.keys['arrowdown']) {
                    moveInput = -1;
                }
                
                // Left/right rotation
                let rotateY = 0;
                if (this.keys['a'] || this.keys['arrowleft']) {
                    rotateY = 1;
                } else if (this.keys['d'] || this.keys['arrowright']) {
                    rotateY = -1;
                }
                
                // Check if car is completely stopped
                const isCarStopped = Math.abs(this.playerVelocity) < 0.5 && Math.abs(this.lateralVelocity) < 0.5;
                
                // When car is stopped with no input, reset all momentum to prevent sliding
                if (isCarStopped && moveInput === 0 && rotateY === 0 && !this.handbrakeActive) {
                    this.playerVelocity = 0;
                    this.lateralVelocity = 0;
                    this.angularVelocity = 0;
                }
                
                // Apply rotation
                if (rotateY !== 0) {
                    // Scale rotation speed based on velocity for more realistic turning
                    // Slower rotation at higher speeds
                    const speedFactor = Math.max(0.2, 1.0 - (Math.abs(this.playerVelocity) / this.playerMaxSpeed));
                    
                    // Base rotation adjustment
                    let rotationAdjustment = rotateY * this.playerRotationSpeed * speedFactor * deltaTime;
                    
                    // Apply rear-wheel drive physics and handbrake effects
                    if (this.handbrakeActive && Math.abs(this.playerVelocity) > 5) {
                        // When handbrake is active and we're moving fast enough:
                        // 1. Increase rotation rate (makes car rotate faster)
                        rotationAdjustment *= 2.0;
                        
                        // 2. Apply additional angular momentum based on current speed
                        // This creates the characteristic "swing" of a handbrake turn
                        const handbrakeRotationBoost = rotateY * Math.abs(this.playerVelocity) * 0.03 * deltaTime;
                        this.angularVelocity += handbrakeRotationBoost;
                        
                        // Continue playing tire squeal sound during drift
                        if (Math.random() < 0.1) {
                            this.playHandbrakeSound();
                        }
                    }
                    
                    // Apply rotation, including any angular velocity from drifting
                    this.player.rotation.y += rotationAdjustment + (this.angularVelocity * deltaTime);
                    
                    // Add some lateral velocity when turning (creates realistic side movement)
                    if (Math.abs(this.playerVelocity) > 10) {
                        // More lateral force at higher speeds
                        const lateralForce = rotateY * 0.5 * Math.abs(this.playerVelocity) / 20;
                        
                        // More lateral force when handbrake is engaged
                        this.lateralVelocity += lateralForce * deltaTime * (this.handbrakeActive ? 3.0 : 1.0);
                    }
                } else {
                    // Still apply any existing angular velocity
                    this.player.rotation.y += this.angularVelocity * deltaTime;
                }
                
                // Apply acceleration/deceleration based on input
                if (moveInput !== 0) {
                    // Accelerate in the input direction
                    if ((moveInput > 0 && this.playerVelocity < 0) || 
                        (moveInput < 0 && this.playerVelocity > 0)) {
                        // Braking (moving in opposite direction of current velocity)
                        this.playerVelocity += moveInput * this.playerDeceleration * deltaTime;
                        
                        // Activate brake lights when braking
                        this.updateBrakeLights(true);
                    } else {
                        // Accelerating - apply rear wheel drive physics
                        // Wheelspin effect when handbrake is active
                        const accelerationFactor = this.handbrakeActive ? 0.3 : 1.0;
                        
                        // Acceleration is reduced at higher speeds (torque curve simulation)
                        const speedScale = 1.0 - (Math.abs(this.playerVelocity) / this.playerMaxSpeed) * 0.7;
                        
                        this.playerVelocity += moveInput * this.playerAcceleration * accelerationFactor * speedScale * deltaTime;
                        
                        // Deactivate brake lights when accelerating
                        this.updateBrakeLights(false);
                    }
                } else if (this.playerVelocity !== 0) {
                    // Apply friction when no input
                    const frictionForce = Math.min(Math.abs(this.playerVelocity), this.playerFriction * deltaTime);
                    this.playerVelocity -= Math.sign(this.playerVelocity) * frictionForce;
                    
                    // Prevent tiny floating point oscillations near zero
                    if (Math.abs(this.playerVelocity) < 0.01) {
                        this.playerVelocity = 0;
                    }
                    
                    // Medium brake lights when coasting (engine braking)
                    this.updateBrakeLights(false);
                } else {
                    // Vehicle is completely stopped
                    this.updateBrakeLights(false);
                }
                
                // Clamp velocity to max speed
                this.playerVelocity = Math.max(-this.playerMaxSpeed, Math.min(this.playerMaxSpeed, this.playerVelocity));
                
                // Only apply movement if we have any velocity (forward, lateral or angular)
                if (Math.abs(this.playerVelocity) > 0.01 || Math.abs(this.lateralVelocity) > 0.01 || Math.abs(this.angularVelocity) > 0.01) {
                    // Calculate forward direction based on player's rotation
                    const angle = this.player.rotation.y;
                    const x = Math.sin(angle) * this.playerVelocity * deltaTime;
                    const z = Math.cos(angle) * this.playerVelocity * deltaTime;
                    
                    // Add lateral movement (side slip) - will be greater with handbrake
                    // Calculate lateral direction (perpendicular to forward)
                    const lateralX = Math.sin(angle + Math.PI/2) * this.lateralVelocity * deltaTime;
                    const lateralZ = Math.cos(angle + Math.PI/2) * this.lateralVelocity * deltaTime;
                    
                    // Store previous position for collision detection
                    const previousPosition = new THREE.Vector3().copy(this.player.position);
                    
                    // Only apply direct movement if not in collision recovery
                    if (!this.inCollisionRecovery) {
                        // Apply both forward and lateral movement
                        this.player.position.x -= (x + lateralX); 
                        this.player.position.z -= (z + lateralZ);
                    }
                    
                    // Create skidmarks if handbrake is active and car is moving
                    if (this.handbrakeActive && Math.abs(this.playerVelocity) > 5) {
                        this.createSkidmarks();
                    }
                    
                    // Handle gradual collision recovery
                    if (this.inCollisionRecovery) {
                        // Increment progress based on speed and time
                        this.collisionProgress += this.collisionRepositionSpeed * deltaTime;
                        
                        if (this.collisionProgress >= 1.0) {
                            // We've completed the recovery
                            this.player.position.copy(this.collisionTargetPosition);
                            this.inCollisionRecovery = false;
                        } else {
                            // Interpolate between start and target positions
                            this.player.position.lerpVectors(
                                this.collisionStartPosition,
                                this.collisionTargetPosition,
                                this.collisionProgress
                            );
                        }
                    }
                    
                    // Check for collisions with buildings and objects
                    const collisionInfo = this.checkVehicleCollisions();
                    
                    if (collisionInfo.collision) {
                        // Handle collision response - realistic bounce off
                        this.handleCollision(collisionInfo, previousPosition);
                        
                        // Create spark effects at collision point
                        this.createSparkEffect(collisionInfo.point);
                    }
                }
                
                // Apply drift physics
                this.applyDriftPhysics(deltaTime);
                
                // Apply smooth rotation transition after collision if needed
                if (this.inRotationTransition) {
                    // Move towards target rotation
                    const currentAngle = this.player.rotation.y;
                    const angleDifference = this.targetRotation - currentAngle;
                    
                    // Normalize angle difference to [-π, π]
                    let normalizedDifference = angleDifference;
                    while (normalizedDifference > Math.PI) normalizedDifference -= 2 * Math.PI;
                    while (normalizedDifference < -Math.PI) normalizedDifference += 2 * Math.PI;
                    
                    if (Math.abs(normalizedDifference) < 0.05) {
                        // Close enough, end transition
                        this.player.rotation.y = this.targetRotation;
                        this.inRotationTransition = false;
                    } else {
                        // Use the speed-based rotation value and apply it with time adjustment
                        // Higher rotationSpeed = faster initial rotation
                        const rotationStep = normalizedDifference * Math.min(1, this.rotationSpeed * deltaTime);
                        this.player.rotation.y += rotationStep;
                        
                        // Gradually decelerate the rotation speed (simulates momentum dissipation)
                        this.rotationSpeed *= (1 - deltaTime * 1.5);
                        
                        // Gradually reduce speed during sharp turns (simulates friction)
                        if (Math.abs(normalizedDifference) > 0.5 && this.playerVelocity > 10) {
                            this.playerVelocity *= (1 - (deltaTime * 0.5));
                        }
                    }
                }

                // Update active spark effects
                this.updateSparkEffects(deltaTime);
            }
            
            checkVehicleCollisions() {
                // Only check if we're not in collision cooldown
                const now = Date.now();
                if (now - this.lastCollisionTime < this.collisionCooldown) {
                    // If we're still in cooldown but not for a wall with the same normal
                    // Check if we're very close to a different wall to prevent getting stuck between walls
                    if (this.lastCollisionNormal) {
                        // Check for critical collisions even during cooldown
                        const carPosition = new THREE.Vector2(this.player.position.x, this.player.position.z);
                        
                        // Check each collidable object
                        for (const obj of this.collidableObjects) {
                            if (obj.type === 'building') {
                                // Calculate if car is VERY close to the building (half normal radius)
                                const halfWidth = obj.width / 2;
                                const halfDepth = obj.depth / 2;
                                
                                // Building boundaries
                                const minX = obj.position.x - halfWidth;
                                const maxX = obj.position.x + halfWidth;
                                const minZ = obj.position.z - halfDepth;
                                const maxZ = obj.position.z + halfDepth;
                                
                                // Car collision circle - is the car colliding with the rectangle?
                                const closestX = Math.max(minX, Math.min(carPosition.x, maxX));
                                const closestZ = Math.max(minZ, Math.min(carPosition.y, maxZ));
                                
                                // Calculate distance from closest point
                                const distanceX = carPosition.x - closestX;
                                const distanceZ = carPosition.y - closestZ;
                                const distanceSquared = distanceX * distanceX + distanceZ * distanceZ;
                                
                                // Check if we're very close (half normal distance)
                                if (distanceSquared < (this.collisionRadius * this.collisionRadius * 0.5)) {
                                    // Calculate collision normal
                                    const collisionNormal = new THREE.Vector2(distanceX, distanceZ).normalize();
                                    
                                    // If this is a significantly different wall (angle > 45 degrees)
                                    // than the one we just hit, handle the collision even in cooldown
                                    const dotProduct = collisionNormal.dot(this.lastCollisionNormal);
                                    if (dotProduct < 0.7) { // cos(45°) ≈ 0.7
                                        this.lastCollisionTime = now;
                                        this.lastCollisionNormal = collisionNormal.clone();
                                        
                                        // Calculate exact collision point
                                        const collisionPoint = new THREE.Vector3(
                                            closestX + collisionNormal.x * this.collisionRadius * 0.5,
                                            obj.height * 0.1, // Slightly above ground level
                                            closestZ + collisionNormal.y * this.collisionRadius * 0.5
                                        );
                                        
                                        return {
                                            collision: true,
                                            normal: collisionNormal,
                                            point: collisionPoint,
                                            object: obj,
                                            critical: true // Flag as a critical collision during cooldown
                                        };
                                    }
                                }
                            }
                        }
                    }
                    
                    return { collision: false };
                }
                
                // Regular collision detection
                const carPosition = new THREE.Vector2(this.player.position.x, this.player.position.z);
                
                // Check each collidable object
                for (const obj of this.collidableObjects) {
                    if (obj.type === 'building') {
                        // Calculate if car is within the building's footprint with some buffer
                        const halfWidth = obj.width / 2;
                        const halfDepth = obj.depth / 2;
                        
                        // Building boundaries
                        const minX = obj.position.x - halfWidth;
                        const maxX = obj.position.x + halfWidth;
                        const minZ = obj.position.z - halfDepth;
                        const maxZ = obj.position.z + halfDepth;
                        
                        // Car collision circle - is the car colliding with the rectangle?
                        // Use a simplified approach: check if the car's circle intersects with the building's rectangle
                        const closestX = Math.max(minX, Math.min(carPosition.x, maxX));
                        const closestZ = Math.max(minZ, Math.min(carPosition.y, maxZ));
                        
                        // Calculate distance from closest point
                        const distanceX = carPosition.x - closestX;
                        const distanceZ = carPosition.y - closestZ;
                        const distanceSquared = distanceX * distanceX + distanceZ * distanceZ;
                        
                        if (distanceSquared < (this.collisionRadius * this.collisionRadius)) {
                            // We have a collision!
                            this.lastCollisionTime = now;
                            
                            // Calculate collision normal (direction to push the car away)
                            const collisionNormal = new THREE.Vector2(distanceX, distanceZ).normalize();
                            this.lastCollisionNormal = collisionNormal.clone();
                            
                            // Calculate exact collision point
                            const collisionPoint = new THREE.Vector3(
                                closestX + collisionNormal.x * this.collisionRadius * 0.5,
                                obj.height * 0.1, // Slightly above ground level
                                closestZ + collisionNormal.y * this.collisionRadius * 0.5
                            );
                            
                            return {
                                collision: true,
                                normal: collisionNormal,
                                point: collisionPoint,
                                object: obj
                            };
                        }
                    }
                }
                
                return { collision: false };
            }
            
            handleCollision(collisionInfo, previousPosition) {
                // Get the car's original speed
                const originalSpeed = Math.abs(this.playerVelocity);
                
                // Create a truly linear relationship between speed and safety margin
                // At speeds below 1.0, there's almost no safety margin (bare minimum to prevent sticking)
                const safetyMargin = originalSpeed < 1.0 ? 0.01 : Math.min(0.12, 0.01 + originalSpeed * 0.004);
                
                // Calculate push vector based on collision normal with linear scaling
                // For extremely low speeds (< 1.0), provide just enough to prevent sticking
                const pushDistance = originalSpeed < 1.0 ? 0.02 : this.collisionRadius * (0.02 + originalSpeed * 0.003);
                const pushbackVector = new THREE.Vector3(
                    collisionInfo.normal.x * pushDistance,
                    0,
                    collisionInfo.normal.y * pushDistance
                );
                
                // Calculate target position (outside the wall)
                const targetPosition = new THREE.Vector3().copy(previousPosition).add(pushbackVector);
                
                // Setup collision recovery
                this.collisionStartPosition.copy(this.player.position);
                this.collisionTargetPosition.copy(targetPosition);
                
                // Make repositioning truly linear with speed
                // At near-zero speeds, almost no movement
                this.collisionRepositionSpeed = originalSpeed < 1.0 ? 1.0 : 1.0 + originalSpeed / 5;
                
                // Reset progress
                this.collisionProgress = 0;
                
                // Enable collision recovery mode
                this.inCollisionRecovery = true;
                
                // Continue with the rest of collision handling
                // Get the car's velocity vector
                const angle = this.player.rotation.y;
                const velocityVector = new THREE.Vector2(
                    -Math.sin(angle) * this.playerVelocity,
                    -Math.cos(angle) * this.playerVelocity
                );
                
                // Calculate how direct the hit was (1.0 = head-on, 0.0 = grazing)
                const dot = velocityVector.x * collisionInfo.normal.x + velocityVector.y * collisionInfo.normal.y;
                const normalizedDot = Math.abs(dot) / (velocityVector.length() * collisionInfo.normal.length());
                
                // --- REVISED PHYSICS MODEL FOR LINEAR SPEED-DEPENDENT COLLISIONS ---
                
                // For extremely low speeds, barely any effect
                if (originalSpeed < 1.5) {
                    this.playerVelocity = 0; // Stop completely
                    this.playCollisionSound(0.1); // Very quiet sound
                    return; // Skip the rest of the collision handling
                }
                
                // Low speeds (1.5-10) get very gentle, proportional bounces
                if (originalSpeed < 10) {
                    // Calculate reflection direction (normalized)
                    const reflectionDir = new THREE.Vector2(
                        velocityVector.x - 2 * dot * collisionInfo.normal.x,
                        velocityVector.y - 2 * dot * collisionInfo.normal.y
                    ).normalize();
                    
                    // Linear energy loss - more speed = more loss, perfectly linear
                    const energyLoss = 0.5 + (originalSpeed / 20); // 0.5 at low speeds, up to 1.0 at 10 speed
                    
                    // Calculate new speed - linear relationship to original speed
                    const newSpeed = originalSpeed * Math.max(0, 1 - energyLoss);
                    
                    // Set the car's new velocity - gentle, proportional bounce
                    this.playerVelocity = newSpeed;
                    
                    // No rotation change for speeds under 5
                    if (originalSpeed < 5) {
                        // Zero rotation change
                        this.playCollisionSound(originalSpeed * 0.1);
                        return;
                    }
                    
                    // Minimal rotation for speeds 5-10, linearly increasing
                    const rotationFactor = (originalSpeed - 5) / 5; // 0 at speed 5, 1.0 at speed 10
                    const maxAngleChange = rotationFactor * 0.1; // Up to ~6 degrees at speed 10
                    
                    // Apply tiny rotation based on which side was hit
                    const sideHit = dot > 0 ? 1 : -1;
                    this.player.rotation.y += maxAngleChange * sideHit;
                    
                    // Play proportional collision sound
                    this.playCollisionSound(originalSpeed * 0.1);
                    return;
                }
                
                // For speeds 10+, use existing logic but with more linear response
                // Calculate reflection direction (normalized)
                const reflectionDir = new THREE.Vector2(
                    velocityVector.x - 2 * dot * collisionInfo.normal.x,
                    velocityVector.y - 2 * dot * collisionInfo.normal.y
                ).normalize();
                
                // MORE REALISTIC PHYSICS WITH LINEAR ENERGY LOSS:
                
                // Linear energy loss based on speed (no quadratic functions)
                const speedBasedEnergyLoss = Math.min(0.95, 0.35 + (originalSpeed / 100));
                
                // Direct hits lose more energy - linear relationship
                const angleBasedEnergyLoss = normalizedDot * 0.85;
                
                // Combine energy losses - linear relationship to speed
                const totalEnergyLoss = Math.min(0.95, speedBasedEnergyLoss + angleBasedEnergyLoss);
                
                // Calculate new speed with more energy loss
                const wallDampingFactor = 0.7; // Walls absorb 30% of energy on all collisions
                const energyFactor = (1 - totalEnergyLoss) * wallDampingFactor;
                const newSpeed = originalSpeed * Math.max(0.01, energyFactor);
                
                // Set the car's new velocity with reduced bounce effect
                this.playerVelocity = newSpeed;
                
                // IMPROVED ROTATION HANDLING:
                if (originalSpeed > 10) {
                    // Calculate new angle from reflection vector
                    const newAngle = Math.atan2(-reflectionDir.x, -reflectionDir.y);
                    
                    // Calculate offset angle for glancing blows - linear with speed
                    const glancingFactor = (1 - normalizedDot); // Higher for glancing blows
                    
                    // Linear speed factor - no quadratic scaling
                    const speedFactor = originalSpeed / 40; // Linear growth relative to speed
                    
                    // Calculate rotational impulse with linear scaling
                    const rotationalImpulse = glancingFactor * speedFactor * Math.PI * 0.4;
                    
                    // Apply rotational impulse in the appropriate direction
                    // (based on which side of the car was hit)
                    const sideHit = dot > 0 ? 1 : -1;
                    const rotationOffset = rotationalImpulse * sideHit;
                    
                    // Set up smooth transition with speed-dependent rotation
                    this.targetRotation = newAngle + rotationOffset;
                    this.inRotationTransition = true;
                    
                    // Linear rotation transition speed based on car speed
                    this.rotationSpeed = 3 + originalSpeed / 10;
                    
                    // Linear slowdown during rotation
                    const angleDifference = Math.abs(this.targetRotation - this.player.rotation.y);
                    if (angleDifference > 0.8 && this.playerVelocity > 10) {
                        // Linear speed reduction
                        this.playerVelocity *= (1 - (speedFactor * 0.4));
                    }
                }
                
                // Play collision sound with volume based on impact force
                this.playCollisionSound(originalSpeed * normalizedDot * 0.05);
                
                // Add damage based on impact force
                if (originalSpeed > 20 && normalizedDot > 0.5) {
                    const damage = Math.floor((originalSpeed / 10) * normalizedDot);
                    document.getElementById('health').textContent = 
                        Math.max(0, parseInt(document.getElementById('health').textContent) - damage);
                }
                
                // Create spark effect at low speeds too
                if (originalSpeed > 3) {
                    this.createSparkEffect(collisionInfo.point);
                }
            }
            
            playCollisionSound(impactSpeed) {
                // Create a simple collision sound with Web Audio API
                // Volume based on impact speed
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // Impact sound properties
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(100 + impactSpeed * 10, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(20, audioContext.currentTime + 0.1);
                    
                    // Volume based on impact
                    const volume = Math.min(0.3, impactSpeed / this.playerMaxSpeed);
                    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                } catch (e) {
                    console.log("Audio not supported or not allowed:", e);
                }
            }
            
            createSparkEffect(position) {
                // Create a particle group for sparks
                // Increase spark count significantly based on speed
                const sparkCount = 25 + Math.floor(Math.abs(this.playerVelocity) / 3);
                const sparkGroup = new THREE.Group();
                // Position the group at the exact collision point, not the car center
                sparkGroup.position.copy(position);
                this.scene.add(sparkGroup);
                
                // Create individual spark particles
                for (let i = 0; i < sparkCount; i++) {
                    // Random spark direction in semicircle facing away from collision
                    // Make sparks spread in a wider arc
                    const angle = Math.random() * Math.PI * 1.5 - Math.PI * 0.25;
                    // Increase speed range for more dynamic effect
                    const speed = 8 + Math.random() * 15; // Higher speed values
                    
                    // Create larger particles
                    const sparkSize = 0.2 + Math.random() * 0.3; // Increased from 0.1 fixed size
                    const sparkGeometry = new THREE.BoxGeometry(sparkSize, sparkSize, sparkSize);
                    
                    // Brighter, more vibrant materials with glow effect
                    const sparkColors = [0xffaa00, 0xffdd00, 0xff5500]; // Orange, yellow, bright orange
                    const sparkMaterial = new THREE.MeshBasicMaterial({
                        color: sparkColors[Math.floor(Math.random() * sparkColors.length)],
                        emissive: 0xffff00,
                        emissiveIntensity: 2, // Increased intensity
                        transparent: true, 
                        opacity: 0.9
                    });
                    
                    const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                    spark.castShadow = false;
                    spark.receiveShadow = false;
                    
                    // Add to group
                    sparkGroup.add(spark);
                    
                    // Random direction and velocity - more upward movement and spread
                    spark.userData = {
                        velocity: new THREE.Vector3(
                            Math.cos(angle) * speed,
                            6 + Math.random() * 12, // More upward velocity
                            Math.sin(angle) * speed
                        ),
                        created: Date.now(),
                        // Add rotation for more dynamic effect
                        rotationSpeed: new THREE.Vector3(
                            Math.random() * 20 - 10,
                            Math.random() * 20 - 10,
                            Math.random() * 20 - 10
                        )
                    };
                }
                
                // Track this spark effect
                this.currentSparks.push({
                    group: sparkGroup,
                    created: Date.now()
                });
                
                // Make low-speed collisions also create sparks, just fewer
                if (Math.abs(this.playerVelocity) < 5) {
                    this.sparkDuration = 300; // Shorter duration for low-speed impacts
                } else {
                    this.sparkDuration = 800; // Longer duration for high-speed impacts
                }
            }
            
            updateSparkEffects(deltaTime) {
                const now = Date.now();
                const gravity = 9.8; // Gravity for spark physics
                
                // Update each spark group
                for (let i = this.currentSparks.length - 1; i >= 0; i--) {
                    const sparkEffect = this.currentSparks[i];
                    const elapsed = now - sparkEffect.created;
                    
                    // Handle smoke particles differently than sparks
                    if (sparkEffect.isSmoke) {
                        // Smoke has longer lifetime
                        if (elapsed > 1500) {
                            this.scene.remove(sparkEffect.group);
                            this.currentSparks.splice(i, 1);
                            continue;
                        }
                        
                        // Update each smoke particle
                        sparkEffect.group.children.forEach(smoke => {
                            // Apply gravity (less than for sparks - smoke rises)
                            smoke.userData.velocity.y -= gravity * 0.3 * deltaTime;
                            
                            // Move smoke based on velocity
                            smoke.position.x += smoke.userData.velocity.x * deltaTime;
                            smoke.position.y += smoke.userData.velocity.y * deltaTime;
                            smoke.position.z += smoke.userData.velocity.z * deltaTime;
                            
                            // Slow down horizontal velocity over time
                            smoke.userData.velocity.x *= 0.98;
                            smoke.userData.velocity.z *= 0.98;
                            
                            // Rotate smoke for dynamic effect
                            smoke.rotation.z += smoke.userData.rotation;
                            
                            // Expand smoke over time
                            const lifeFraction = elapsed / smoke.userData.fadeTime;
                            const scale = 1.0 + lifeFraction * 3.0; // Gets 4x larger
                            smoke.scale.set(scale, scale, 1);
                            
                            // Fade out smoke as it ages
                            smoke.material.opacity = Math.max(0, 0.4 - lifeFraction * 0.4);
                        });
                        
                        continue;
                    }
                    
                    // Handle regular spark particles - original code
                    // Remove old spark effects
                    if (elapsed > this.sparkDuration) {
                        this.scene.remove(sparkEffect.group);
                        this.currentSparks.splice(i, 1);
                        continue;
                    }
                    
                    // Update each individual spark particle
                    sparkEffect.group.children.forEach(spark => {
                        // Apply gravity to velocity with more gradual effect
                        spark.userData.velocity.y -= gravity * 1.5 * deltaTime;
                        
                        // Move spark based on velocity
                        spark.position.x += spark.userData.velocity.x * deltaTime;
                        spark.position.y += spark.userData.velocity.y * deltaTime;
                        spark.position.z += spark.userData.velocity.z * deltaTime;
                        
                        // Add rotation to sparks for more dynamic effect
                        spark.rotation.x += spark.userData.rotationSpeed.x * deltaTime;
                        spark.rotation.y += spark.userData.rotationSpeed.y * deltaTime;
                        spark.rotation.z += spark.userData.rotationSpeed.z * deltaTime;
                        
                        // If spark hits ground, bounce with reduced energy
                        if (spark.position.y < 0.1) {
                            spark.position.y = 0.1;
                            spark.userData.velocity.y = -spark.userData.velocity.y * 0.4; // More bounce
                            
                            // Reduce horizontal velocity (friction with ground)
                            spark.userData.velocity.x *= 0.8;
                            spark.userData.velocity.z *= 0.8;
                        }
                        
                        // Fade out spark as it ages - use a different curve that keeps sparks visible longer
                        const sparkAge = elapsed;
                        // Keep full opacity for first half of life, then fade
                        const lifeFraction = sparkAge / this.sparkDuration;
                        const opacity = lifeFraction < 0.6 ? 1.0 : 1.0 - ((lifeFraction - 0.6) / 0.4);
                        spark.material.opacity = opacity;
                        
                        // Scale sparks - start larger, then get smaller
                        const scale = 1.0 - (lifeFraction * 0.7);
                        spark.scale.set(scale, scale, scale);
                        
                        // Colorful effect - transition from yellow to red as sparks age
                        if (lifeFraction > 0.3) {
                            // Transition color from original to red
                            const r = 1.0;
                            const g = Math.max(0, 0.7 - lifeFraction);
                            const b = 0;
                            spark.material.color.setRGB(r, g, b);
                        }
                    });
                }
            }
            
            updatePedestrian(deltaTime) {
                // Pedestrian movement constants
                const pedestrianSpeed = 10; // Reduced from 20 to 10 (50% slower)
                const rotationSpeed = 2.5; // Speed of turning in radians per second
                
                // Get movement input
                let moveForward = 0;
                let moveRight = 0;
                let rotate = 0;
                
                // Movement controls
                if (this.keys['w'] || this.keys['arrowup']) moveForward = 1;
                if (this.keys['s'] || this.keys['arrowdown']) moveForward = -1;
                
                // Turning controls
                if (this.keys['a'] || this.keys['arrowleft']) rotate = 1; // Turn left
                if (this.keys['d'] || this.keys['arrowright']) rotate = -1; // Turn right
                
                // Store previous position for collision detection
                const previousPosition = new THREE.Vector3().copy(this.pedestrian.position);
                
                // Rotate pedestrian based on input
                if (rotate !== 0) {
                    this.pedestrian.rotation.y += rotate * rotationSpeed * deltaTime;
                }
                
                // Calculate direction based on pedestrian's current rotation
                let moveDirection = new THREE.Vector3(0, 0, 0);
                if (moveForward !== 0) {
                    // Get forward direction from rotation
                    const directionX = Math.sin(this.pedestrian.rotation.y) * moveForward;
                    const directionZ = Math.cos(this.pedestrian.rotation.y) * moveForward;
                    
                    // Move the pedestrian in the direction they're facing
                    this.pedestrian.position.x += directionX * pedestrianSpeed * deltaTime;
                    this.pedestrian.position.z += directionZ * pedestrianSpeed * deltaTime;
                    
                    // Check for collisions after movement
                    const pedestrianCollisionInfo = this.checkPedestrianCollisions();
                    if (pedestrianCollisionInfo.collision) {
                        // Simple collision response - move back to previous position
                        this.pedestrian.position.copy(previousPosition);
                    }
                }
                
                // Check if pedestrian is close enough to vehicle to enter it
                if (this.player && this.pedestrian) {
                    const distance = this.pedestrian.position.distanceTo(this.player.position);
                    if (distance < 5) { // Within 5 units of vehicle
                        document.getElementById('info').textContent = "GTA 2 Clone - Press E to enter vehicle";
                    } else {
                        document.getElementById('info').textContent = "GTA 2 Clone - 3D Version";
                    }
                }
            }
            
            checkPedestrianCollisions() {
                // Simple collision detection between pedestrian and buildings
                const pedestrianPosition = new THREE.Vector2(this.pedestrian.position.x, this.pedestrian.position.z);
                const pedestrianRadius = 0.5; // Smaller collision radius for pedestrian
                
                // Check each collidable object
                for (const obj of this.collidableObjects) {
                    if (obj.type === 'building') {
                        // Calculate if pedestrian is within the building's footprint
                        const halfWidth = obj.width / 2;
                        const halfDepth = obj.depth / 2;
                        
                        // Building boundaries
                        const minX = obj.position.x - halfWidth;
                        const maxX = obj.position.x + halfWidth;
                        const minZ = obj.position.z - halfDepth;
                        const maxZ = obj.position.z + halfDepth;
                        
                        // Pedestrian collision circle - is it colliding with the rectangle?
                        const closestX = Math.max(minX, Math.min(pedestrianPosition.x, maxX));
                        const closestZ = Math.max(minZ, Math.min(pedestrianPosition.y, maxZ));
                        
                        // Calculate distance from closest point
                        const distanceX = pedestrianPosition.x - closestX;
                        const distanceZ = pedestrianPosition.y - closestZ;
                        const distanceSquared = distanceX * distanceX + distanceZ * distanceZ;
                        
                        if (distanceSquared < (pedestrianRadius * pedestrianRadius)) {
                            // We have a collision!
                            return { collision: true };
                        }
                    }
                }
                
                return { collision: false };
            }
            
            createCityGrid() {
                // Create a simple city grid
                const blockSize = 50;
                const streetWidth = 16;
                const gridSize = 3; // 3x3 grid of city blocks
                
                // Create the grid of buildings and streets
                for (let x = -gridSize; x <= gridSize; x++) {
                    for (let z = -gridSize; z <= gridSize; z++) {
                        // Position for this block
                        const posX = x * (blockSize + streetWidth);
                        const posZ = z * (blockSize + streetWidth);
                        
                        // Skip the center block (make it a park)
                        if (x === 0 && z === 0) {
                            this.createPark(posX, posZ, blockSize);
                            continue;
                        }
                        
                        // Create a block of buildings
                        this.createCityBlock(posX, posZ, blockSize);
                    }
                }
                
                // Create horizontal streets
                for (let x = -gridSize; x <= gridSize; x++) {
                    for (let z = -gridSize-1; z <= gridSize; z++) {
                        const posX = x * (blockSize + streetWidth);
                        const posZ = z * (blockSize + streetWidth) + blockSize/2 + streetWidth/2;
                        this.createRoad(posX, posZ, blockSize + streetWidth, streetWidth, true);
                    }
                }
                
                // Create vertical streets
                for (let x = -gridSize-1; x <= gridSize; x++) {
                    for (let z = -gridSize; z <= gridSize; z++) {
                        const posX = x * (blockSize + streetWidth) + blockSize/2 + streetWidth/2;
                        const posZ = z * (blockSize + streetWidth);
                        this.createRoad(posX, posZ, streetWidth, blockSize + streetWidth, false);
                    }
                }
                
                // Create intersections (simple crossroads)
                for (let x = -gridSize; x <= gridSize+1; x++) {
                    for (let z = -gridSize; z <= gridSize+1; z++) {
                        const posX = x * (blockSize + streetWidth) - blockSize/2 - streetWidth/2;
                        const posZ = z * (blockSize + streetWidth) - blockSize/2 - streetWidth/2;
                        this.createIntersection(posX, posZ, streetWidth);
                    }
                }
            }
            
            createCityBlock(x, z, size) {
                // Create a block of buildings
                const buildingsPerSide = 4;
                const buildingSize = size / buildingsPerSide;
                const padding = buildingSize * 0.1; // Space between buildings
                
                for (let bx = 0; bx < buildingsPerSide; bx++) {
                    for (let bz = 0; bz < buildingsPerSide; bz++) {
                        // Randomly skip some buildings to create variety
                        if (Math.random() < 0.3) continue;
                        
                        const buildingX = x - size/2 + bx * buildingSize + buildingSize/2;
                        const buildingZ = z - size/2 + bz * buildingSize + buildingSize/2;
                        
                        // Randomly determine building height
                        const height = 5 + Math.random() * 15;
                        
                        // Create building with reduced size for spacing
                        const actualSize = buildingSize - padding;
                        this.createBuilding(buildingX, buildingZ, actualSize, actualSize, height);
                    }
                }
            }
            
            createPark(x, z, size) {
                // Create a park with grass
                const parkGeometry = new THREE.PlaneGeometry(size, size);
                const parkMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x33aa33, // Green
                    roughness: 0.9
                });
                const park = new THREE.Mesh(parkGeometry, parkMaterial);
                park.rotation.x = degToRad(-90); // Rotate to be horizontal
                park.position.set(x, 0.01, z); // Slightly above ground to avoid z-fighting
                park.receiveShadow = true;
                this.scene.add(park);
                
                // Add some trees or decorations
                const numTrees = 12;
                for (let i = 0; i < numTrees; i++) {
                    const treeX = x - size/2 + Math.random() * size;
                    const treeZ = z - size/2 + Math.random() * size;
                    this.createTree(treeX, treeZ);
                }
            }
            
            createTree(x, z) {
                // Tree trunk (brown cylinder)
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.8, 3, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513, // Brown
                    roughness: 0.9
                });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(x, 1.5, z);
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                this.scene.add(trunk);
                
                // Tree top (green cone)
                const topGeometry = new THREE.ConeGeometry(3, 6, 8);
                const topMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x228B22, // Forest green
                    roughness: 0.8
                });
                const top = new THREE.Mesh(topGeometry, topMaterial);
                top.position.set(x, 6, z);
                top.castShadow = true;
                top.receiveShadow = true;
                this.scene.add(top);
            }
            
            createBuilding(x, z, width, depth, height) {
                // Create building geometry
                const geometry = new THREE.BoxGeometry(width, height, depth);
                
                // Random color for variety
                const colors = [0x999999, 0x888888, 0x777777, 0xaaaaaa, 0xcccccc];
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                const material = new THREE.MeshStandardMaterial({ 
                    color: color,
                    roughness: 0.7,
                    metalness: 0.2
                });
                
                const building = new THREE.Mesh(geometry, material);
                building.position.set(x, height/2, z);
                building.castShadow = true;
                building.receiveShadow = true;
                this.scene.add(building);
                
                // Add building to collidable objects array
                this.collidableObjects.push({
                    type: 'building',
                    mesh: building,
                    position: new THREE.Vector3(x, 0, z), // Ground level position for collision
                    width: width,
                    depth: depth,
                    height: height
                });
                
                // Add windows (simple texture or geometry)
                this.addBuildingWindows(building, width, depth, height);
                
                return building;
            }
            
            addBuildingWindows(building, width, depth, height) {
                // Simple window pattern using small boxes
                const windowSize = 0.8;
                const windowSpacing = 2;
                const windowsPerFloor = Math.max(1, Math.floor(width / windowSpacing));
                const floors = Math.max(1, Math.floor(height / windowSpacing));
                
                const windowMaterial = new THREE.MeshStandardMaterial({
                    color: 0x88ccff, // Light blue
                    emissive: 0x88ccff,
                    emissiveIntensity: 0.2,
                    roughness: 0.1,
                    metalness: 0.9
                });
                
                // Windows on front face
                for (let floor = 0; floor < floors; floor++) {
                    for (let w = 0; w < windowsPerFloor; w++) {
                        const windowGeometry = new THREE.BoxGeometry(windowSize, windowSize, 0.1);
                        const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
                        
                        const wx = -width/2 + w * windowSpacing + windowSpacing/2;
                        const wy = -height/2 + floor * windowSpacing + windowSpacing/2;
                        
                        windowMesh.position.set(wx, wy, depth/2 + 0.05);
                        building.add(windowMesh);
                        
                        // Add window on the back
                        const backWindow = windowMesh.clone();
                        backWindow.position.set(wx, wy, -depth/2 - 0.05);
                        backWindow.rotation.y = Math.PI;
                        building.add(backWindow);
                    }
                }
                
                // Windows on side faces
                const sideWindowsPerFloor = Math.max(1, Math.floor(depth / windowSpacing));
                
                for (let floor = 0; floor < floors; floor++) {
                    for (let w = 0; w < sideWindowsPerFloor; w++) {
                        const windowGeometry = new THREE.BoxGeometry(0.1, windowSize, windowSize);
                        const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
                        
                        const wz = -depth/2 + w * windowSpacing + windowSpacing/2;
                        const wy = -height/2 + floor * windowSpacing + windowSpacing/2;
                        
                        windowMesh.position.set(width/2 + 0.05, wy, wz);
                        building.add(windowMesh);
                        
                        // Add window on the opposite side
                        const leftWindow = windowMesh.clone();
                        leftWindow.position.set(-width/2 - 0.05, wy, wz);
                        leftWindow.rotation.y = Math.PI;
                        building.add(leftWindow);
                    }
                }
            }
            
            createRoad(x, z, width, depth, isHorizontal) {
                // Create road surface
                const roadGeometry = new THREE.PlaneGeometry(width, depth);
                const roadMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x444444, // Dark gray for asphalt
                    roughness: 0.9
                });
                const road = new THREE.Mesh(roadGeometry, roadMaterial);
                road.rotation.x = degToRad(-90); // Rotate to be horizontal
                road.position.set(x, 0.02, z); // Slightly above ground
                road.receiveShadow = true;
                this.scene.add(road);
                
                // Add yellow lines in the middle of the road
                const lineWidth = 0.5;
                const lineDepth = isHorizontal ? depth * 0.8 : width * 0.8;
                const lineGeometry = new THREE.PlaneGeometry(
                    isHorizontal ? lineWidth : lineDepth,
                    isHorizontal ? lineDepth : lineWidth
                );
                const lineMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffff00, // Yellow
                    roughness: 0.5
                });
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.rotation.x = degToRad(-90);
                line.position.set(x, 0.03, z); // Slightly above road
                line.receiveShadow = true;
                this.scene.add(line);
            }
            
            createIntersection(x, z, size) {
                // Create intersection (just a square of road)
                const intersectionGeometry = new THREE.PlaneGeometry(size, size);
                const intersectionMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x444444, // Dark gray for asphalt
                    roughness: 0.9
                });
                const intersection = new THREE.Mesh(intersectionGeometry, intersectionMaterial);
                intersection.rotation.x = degToRad(-90);
                intersection.position.set(x, 0.02, z); // Slightly above ground
                intersection.receiveShadow = true;
                this.scene.add(intersection);
                
                // Add zebra crossings
                this.addZebraCrossing(x, z, size);
            }
            
            addZebraCrossing(x, z, size) {
                // Create zebra crossing stripes
                const stripeCount = 4;
                const stripeWidth = 1;
                const stripeLength = size * 0.6;
                const gap = size / (stripeCount + 1);
                
                const stripeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff, // White
                    roughness: 0.5
                });
                
                // Horizontal stripes
                for (let i = 1; i <= stripeCount; i++) {
                    const stripeGeometry = new THREE.PlaneGeometry(stripeLength, stripeWidth);
                    const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                    stripe.rotation.x = degToRad(-90);
                    stripe.position.set(x, 0.03, z - size/2 + i * gap); // Slightly above road
                    stripe.receiveShadow = true;
                    this.scene.add(stripe);
                }
                
                // Vertical stripes
                for (let i = 1; i <= stripeCount; i++) {
                    const stripeGeometry = new THREE.PlaneGeometry(stripeWidth, stripeLength);
                    const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                    stripe.rotation.x = degToRad(-90);
                    stripe.position.set(x - size/2 + i * gap, 0.03, z); // Slightly above road
                    stripe.receiveShadow = true;
                    this.scene.add(stripe);
                }
            }
            
            createPlayerVehicle() {
                // Create a simple group to hold car parts
                this.player = new THREE.Group();
                this.player.position.set(0, 0.5, 0);
                this.scene.add(this.player);
                
                // Car dimensions - sporty profile
                const carWidth = 2.0;
                const carHeight = 0.4; // Very low profile for a sports car
                const carLength = 4.2;
                
                // Main body - low and sleek
                const bodyGeometry = new THREE.BoxGeometry(carWidth, carHeight, carLength);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000, // Bright red for sports car
                    roughness: 0.2,
                    metalness: 0.8
                });
                
                const carBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
                carBody.position.y = carHeight/2 + 0.1;
                carBody.castShadow = true;
                carBody.receiveShadow = true;
                this.player.add(carBody);
                
                // Add roof section (smaller than body for sporty look)
                const roofWidth = carWidth * 0.6;
                const roofHeight = 0.25;
                const roofLength = carLength * 0.45;
                
                const roofGeometry = new THREE.BoxGeometry(roofWidth, roofHeight, roofLength);
                const roofMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xdd0000, // Slightly darker red
                    roughness: 0.3,
                    metalness: 0.7
                });
                
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.y = carHeight + roofHeight/2 + 0.1;
                roof.position.z = -carLength * 0.05; // Slightly forward from center
                roof.castShadow = true;
                this.player.add(roof);
                
                // Windows (for visibility from top view)
                const windowMaterial = new THREE.MeshStandardMaterial({
                    color: 0x88ccff,
                    roughness: 0.1,
                    metalness: 0.9,
                    transparent: true,
                    opacity: 0.7
                });
                
                // Windshield
                const windshieldGeometry = new THREE.PlaneGeometry(roofWidth * 0.9, roofLength * 0.3);
                const windshield = new THREE.Mesh(windshieldGeometry, windowMaterial);
                windshield.rotation.x = degToRad(-90);
                windshield.position.set(0, carHeight + roofHeight + 0.02, -roofLength * 0.5);
                this.player.add(windshield);
                
                // Rear window
                const rearWindow = windshield.clone();
                rearWindow.position.z = roofLength * 0.4;
                this.player.add(rearWindow);
                
                // Side windows (will be visible from top)
                const sideWindowGeometry = new THREE.PlaneGeometry(roofLength * 0.8, roofHeight * 0.8);
                
                // Left side window
                const leftWindow = new THREE.Mesh(sideWindowGeometry, windowMaterial);
                leftWindow.rotation.y = degToRad(90);
                leftWindow.position.set(-roofWidth/2 - 0.01, carHeight + roofHeight/2 + 0.1, 0);
                this.player.add(leftWindow);
                
                // Right side window
                const rightWindow = leftWindow.clone();
                rightWindow.rotation.y = degToRad(-90);
                rightWindow.position.x = roofWidth/2 + 0.01;
                this.player.add(rightWindow);
                
                // Front detail (grill and bumper)
                const frontDetailGeometry = new THREE.BoxGeometry(carWidth * 0.9, carHeight * 0.5, carLength * 0.05);
                const frontDetailMaterial = new THREE.MeshStandardMaterial({
                    color: 0x111111,
                    roughness: 0.8
                });
                
                const frontDetail = new THREE.Mesh(frontDetailGeometry, frontDetailMaterial);
                frontDetail.position.set(0, carHeight * 0.3, -carLength/2 - 0.05);
                this.player.add(frontDetail);
                
                // Rear spoiler - important visual element for top-down view
                const spoilerWidth = carWidth * 0.8;
                const spoilerHeight = 0.12;
                const spoilerDepth = 0.3;
                
                const spoilerGeometry = new THREE.BoxGeometry(spoilerWidth, spoilerHeight, spoilerDepth);
                const spoilerMaterial = new THREE.MeshStandardMaterial({
                    color: 0x222222,
                    roughness: 0.5,
                    metalness: 0.6
                });
                
                const spoiler = new THREE.Mesh(spoilerGeometry, spoilerMaterial);
                spoiler.position.set(0, carHeight + roofHeight * 0.5, carLength/2 - spoilerDepth/2);
                this.player.add(spoiler);
                
                // Spoiler stands
                const standGeometry = new THREE.BoxGeometry(0.1, spoilerHeight * 2, spoilerDepth/2);
                const leftStand = new THREE.Mesh(standGeometry, spoilerMaterial);
                leftStand.position.set(-spoilerWidth/2 + 0.1, carHeight + spoilerHeight/2, carLength/2 - spoilerDepth/2);
                this.player.add(leftStand);
                
                const rightStand = leftStand.clone();
                rightStand.position.x = spoilerWidth/2 - 0.1;
                this.player.add(rightStand);
                
                // Headlights (clearly visible from top)
                const headlightGeometry = new THREE.BoxGeometry(carWidth * 0.2, carHeight * 0.3, 0.1);
                const headlightMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    emissive: 0xffffcc,
                    emissiveIntensity: 0.5
                });
                
                // Left headlight
                const leftHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
                leftHeadlight.position.set(-carWidth * 0.3, carHeight * 0.5, -carLength/2 - 0.06);
                this.player.add(leftHeadlight);
                
                // Right headlight
                const rightHeadlight = leftHeadlight.clone();
                rightHeadlight.position.x = carWidth * 0.3;
                this.player.add(rightHeadlight);
                
                // Add real headlight spotlights
                this.addHeadlightSpotlights(leftHeadlight, rightHeadlight, carLength);
                
                // Taillights (very visible from top)
                const taillightGeometry = new THREE.BoxGeometry(carWidth * 0.2, carHeight * 0.3, 0.1);
                const taillightMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.5
                });
                
                // Left taillight
                const leftTaillight = new THREE.Mesh(taillightGeometry, taillightMaterial);
                leftTaillight.position.set(-carWidth * 0.3, carHeight * 0.5, carLength/2 + 0.06);
                this.player.add(leftTaillight);
                
                // Right taillight
                const rightTaillight = leftTaillight.clone();
                rightTaillight.position.x = carWidth * 0.3;
                this.player.add(rightTaillight);
                
                // Add real taillight point lights
                this.addTaillightPointLights(leftTaillight, rightTaillight);
                
                // Wheels - make them more visible from top-down view
                this.addSimpleSportyWheels(carWidth, carLength);
                
                return this.player;
            }
            
            addSimpleSportyWheels(carWidth, carLength) {
                const wheelRadius = 0.4;
                const wheelThickness = 0.2;
                
                // Create wheel geometry with more detail visible from top
                const wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelThickness, 16);
                const wheelMaterial = new THREE.MeshStandardMaterial({
                    color: 0x222222,
                    roughness: 0.9
                });
                
                // Create hubcap geometry
                const hubcapGeometry = new THREE.CylinderGeometry(wheelRadius * 0.6, wheelRadius * 0.6, wheelThickness + 0.02, 5);
                const hubcapMaterial = new THREE.MeshStandardMaterial({
                    color: 0xC0C0C0, // Silver
                    roughness: 0.3,
                    metalness: 0.8
                });
                
                // Function to create a wheel at a specific position
                const createWheel = (x, z) => {
                    const wheelGroup = new THREE.Group();
                    
                    // Tire
                    const tire = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    tire.rotation.z = Math.PI / 2; // Correct orientation
                    tire.castShadow = true;
                    wheelGroup.add(tire);
                    
                    // Hubcap
                    const hubcap = new THREE.Mesh(hubcapGeometry, hubcapMaterial);
                    hubcap.rotation.z = Math.PI / 2;
                    // Add a small offset to prevent z-fighting
                    hubcap.position.set(0, 0.01, 0);
                    wheelGroup.add(hubcap);
                    
                    // Position wheel on car
                    wheelGroup.position.set(x, wheelRadius, z);
                    this.player.add(wheelGroup);
                    
                    return wheelGroup;
                };
                
                // Position wheels relative to car body
                const xOffset = carWidth/2 * 0.9; // Slightly inset from edge
                const zOffset = carLength/3;      // Position at 1/3 and 2/3 of car length
                
                createWheel(-xOffset, -zOffset);  // Front left
                createWheel(xOffset, -zOffset);   // Front right
                createWheel(-xOffset, zOffset);   // Rear left
                createWheel(xOffset, zOffset);    // Rear right
            }
            
            toggleVehicle() {
                if (this.isInVehicle) {
                    // Exit vehicle
                    this.createPedestrian();
                    this.player.visible = true; // Keep vehicle visible
                    this.lastVehiclePosition.copy(this.player.position);
                    this.lastVehicleRotation = this.player.rotation.y;
                    // Reset vehicle velocity when exiting
                    this.playerVelocity = 0;
                    // Set camera height for pedestrian view
                    this.targetCameraHeight = 25;
                    
                    // Update control instructions for the new pedestrian controls
                    document.querySelector('.control-instructions').textContent = 
                        "Controls: W/S or Up/Down to move forward/backward | A/D or Left/Right to turn | E to enter vehicles | SPACE to shoot";
                    
                    // Show vehicle health display when not in vehicle
                    setTimeout(() => this.updateVehicleHealthDisplay(), 100);
                } else {
                    // Check distance to vehicle
                    const distance = this.pedestrian.position.distanceTo(this.player.position);
                    if (distance < 5) { // Can only enter if close to vehicle
                        // Enter vehicle
                        this.scene.remove(this.pedestrian);
                        this.pedestrian = null;
                        // Set camera height for vehicle view
                        this.targetCameraHeight = this.CAMERA_HEIGHT;
                        
                        // Update control instructions
                        document.querySelector('.control-instructions').textContent = 
                            "Controls: WASD or Arrow Keys to move | E to exit vehicles | L to toggle lights | K to toggle day/night | SPACE for handbrake";
                        
                        // Hide vehicle health display when in vehicle
                        setTimeout(() => this.updateVehicleHealthDisplay(), 100);
                    } else {
                        return; // Too far from vehicle
                    }
                }
                
                this.isInVehicle = !this.isInVehicle;
                document.getElementById('info').textContent = "GTA 2 Clone - 3D Version";
            }
            
            createPedestrian() {
                // Create a group to hold all pedestrian parts
                this.pedestrian = new THREE.Group();
                
                // Colors
                const skinColor = 0xffdbac;
                const shirtColor = 0x3366cc; // Blue shirt
                const pantsColor = 0x333333; // Dark gray pants
                const shoeColor = 0x111111; // Black shoes
                
                // Materials
                const skinMaterial = new THREE.MeshStandardMaterial({ 
                    color: skinColor,
                    roughness: 0.7
                });
                const shirtMaterial = new THREE.MeshStandardMaterial({ 
                    color: shirtColor,
                    roughness: 0.8
                });
                const pantsMaterial = new THREE.MeshStandardMaterial({ 
                    color: pantsColor,
                    roughness: 0.8
                });
                const shoeMaterial = new THREE.MeshStandardMaterial({ 
                    color: shoeColor,
                    roughness: 0.9
                });
                
                // Head (sphere)
                const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const head = new THREE.Mesh(headGeometry, skinMaterial);
                head.position.y = 1.6;
                head.castShadow = true;
                this.pedestrian.add(head);
                
                // Torso (slightly tapered box)
                const torsoGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.3);
                const torso = new THREE.Mesh(torsoGeometry, shirtMaterial);
                torso.position.y = 1.1;
                torso.castShadow = true;
                this.pedestrian.add(torso);
                
                // Arms
                this.addLimb(this.pedestrian, 0.15, 0.5, 0.15, 0.3, 1.1, 0, shirtMaterial, true);  // Left arm
                this.addLimb(this.pedestrian, -0.15, 0.5, 0.15, 0.3, 1.1, 0, shirtMaterial, true); // Right arm
                
                // Legs
                this.addLimb(this.pedestrian, 0.2, 0, 0, 0.15, 0.6, 0.15, pantsMaterial, false);  // Left leg
                this.addLimb(this.pedestrian, -0.2, 0, 0, 0.15, 0.6, 0.15, pantsMaterial, false); // Right leg
                
                // Hands
                const handGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const leftHand = new THREE.Mesh(handGeometry, skinMaterial);
                leftHand.position.set(0.3, 0.85, 0);
                this.pedestrian.add(leftHand);
                
                const rightHand = new THREE.Mesh(handGeometry, skinMaterial);
                rightHand.position.set(-0.3, 0.85, 0);
                this.pedestrian.add(rightHand);
                
                // Feet (shoes)
                const shoeGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.3);
                const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
                leftShoe.position.set(0.2, 0.05, 0.05);
                this.pedestrian.add(leftShoe);
                
                const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
                rightShoe.position.set(-0.2, 0.05, 0.05);
                this.pedestrian.add(rightShoe);
                
                // Position pedestrian next to vehicle with slight offset
                const offset = new THREE.Vector3(
                    Math.sin(this.player.rotation.y) * 3,
                    0,
                    Math.cos(this.player.rotation.y) * 3
                );
                
                this.pedestrian.position.copy(this.player.position).add(offset);
                this.pedestrian.position.y = 0; // Set to ground level
                this.pedestrian.castShadow = true;
                this.pedestrian.receiveShadow = true;
                this.scene.add(this.pedestrian);
                
                return this.pedestrian;
            }
            
            addLimb(parentGroup, x, y, z, width, height, depth, material, isArm) {
                // Create a limb (arm or leg)
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const limb = new THREE.Mesh(geometry, material);
                
                // For arms, center is near shoulder
                // For legs, center is near hip
                const centerY = isArm ? height * 0.3 : height * 0.4;
                
                limb.position.set(x, y + centerY, z);
                limb.castShadow = true;
                parentGroup.add(limb);
                
                return limb;
            }
            
            toggleLights() {
                this.lightsOn = !this.lightsOn;
                if (this.lightsOn) {
                    // Turn on headlights and taillights
                    this.headlights.forEach(light => {
                        if (light instanceof THREE.Light) {
                            light.intensity = 2.0; // Increased from 1.3 to 2.0 for stronger illumination
                        } else if (light.flare) {
                            light.flare.material.opacity = 0.8;
                        }
                    });
                    this.taillights.forEach(light => {
                        if (light instanceof THREE.Light) {
                            light.intensity = 0.5; // Dimmer when not braking
                        } else if (light.flare) {
                            light.flare.material.opacity = 0.6;
                        }
                    });
                } else {
                    // Turn off headlights and taillights
                    this.headlights.forEach(light => {
                        if (light instanceof THREE.Light) {
                            light.intensity = 0;
                        } else if (light.flare) {
                            light.flare.material.opacity = 0;
                        }
                    });
                    this.taillights.forEach(light => {
                        if (light instanceof THREE.Light) {
                            light.intensity = 0;
                        } else if (light.flare) {
                            light.flare.material.opacity = 0;
                        }
                    });
                }
                
                // Update info text to show light status
                document.getElementById('info').textContent = this.lightsOn ? 
                    "GTA 2 Clone - Lights ON (Press L to toggle)" : 
                    "GTA 2 Clone - Lights OFF (Press L to toggle)";
            }
            
            updateBrakeLights(isBraking) {
                // Only update if lights are on
                if (!this.lightsOn) return;
                
                this.taillights.forEach(light => {
                    if (light instanceof THREE.Light) {
                        // Brighter when braking
                        light.intensity = isBraking ? 1.5 : 0.5;
                    } else if (light.flare) {
                        // Larger flare when braking
                        light.flare.material.opacity = isBraking ? 1.0 : 0.6;
                        light.flare.scale.set(
                            isBraking ? 1.5 : 1.0,
                            isBraking ? 1.5 : 1.0,
                            1.0
                        );
                    }
                });
            }
            
            addHeadlightSpotlights(leftHeadlight, rightHeadlight, carLength) {
                // Create spotlight for left headlight with improved parameters
                const leftSpotlight = new THREE.SpotLight(
                    0xffffee,     // color
                    0,            // intensity (will be set when toggled on)
                    60,           // distance (increased from 50)
                    Math.PI / 4,  // angle (widened from Math.PI/5)
                    0.8,          // penumbra (increased from 0.5 for softer edges)
                    1             // decay (reduced from 2 for better distance coverage)
                );
                leftSpotlight.position.copy(leftHeadlight.position);
                // Position slightly forward and higher from the headlight mesh
                leftSpotlight.position.z -= 0.1;
                leftSpotlight.position.y += 0.2; // Raise slightly for better angle to ground
                
                // Target for the spotlight - positioned to hit the ground ahead of the car
                const leftTarget = new THREE.Object3D();
                leftTarget.position.set(
                    leftSpotlight.position.x, 
                    -0.5,         // Less extreme downward angle to illuminate more of the road
                    leftSpotlight.position.z - 15 // 15 units ahead to illuminate more road
                );
                this.player.add(leftTarget);
                leftSpotlight.target = leftTarget;
                
                // Improved shadow settings for better ground visibility
                leftSpotlight.castShadow = true;
                leftSpotlight.shadow.mapSize.width = 1024;  // Increased from 512
                leftSpotlight.shadow.mapSize.height = 1024; // Increased from 512
                leftSpotlight.shadow.camera.near = 0.1;     // Closer near plane
                leftSpotlight.shadow.camera.far = 60;       // Match light distance
                leftSpotlight.shadow.bias = -0.0005;        // Reduce shadow acne
                
                // Create spotlight for right headlight (similar to left)
                const rightSpotlight = new THREE.SpotLight(
                    0xffffee,     // color
                    0,            // intensity (will be set when toggled on)
                    60,           // distance
                    Math.PI / 4,  // angle
                    0.8,          // penumbra
                    1             // decay
                );
                rightSpotlight.position.copy(rightHeadlight.position);
                rightSpotlight.position.z -= 0.1;
                rightSpotlight.position.y += 0.2; // Raise slightly
                
                const rightTarget = new THREE.Object3D();
                rightTarget.position.set(
                    rightSpotlight.position.x,
                    -2, // Point more downward toward ground (was 0)
                    rightSpotlight.position.z - 10 // 10 units ahead (was 20 - shorter to point more down)
                );
                this.player.add(rightTarget);
                rightSpotlight.target = rightTarget;
                
                // Configure shadows for both spotlights
                leftSpotlight.castShadow = true;
                rightSpotlight.castShadow = true;
                
                // Optimize shadow map settings
                leftSpotlight.shadow.mapSize.width = 512;
                leftSpotlight.shadow.mapSize.height = 512;
                rightSpotlight.shadow.mapSize.width = 512;
                rightSpotlight.shadow.mapSize.height = 512;
                
                // Add light to car
                this.player.add(leftSpotlight);
                this.player.add(rightSpotlight);
                
                // Store light references for toggling
                this.headlights.push(leftSpotlight, rightSpotlight);
                
                // Start with lights off
                leftSpotlight.intensity = 0;
                rightSpotlight.intensity = 0;
                
                // Add lens flare effect
                this.addLensFlare(leftHeadlight.position, 0xffffee);
                this.addLensFlare(rightHeadlight.position, 0xffffee);
            }
            
            addTaillightPointLights(leftTaillight, rightTaillight) {
                // Tail lights are red point lights
                const leftLight = new THREE.PointLight(0xff0000, 0, 20, 2);
                leftLight.position.copy(leftTaillight.position);
                // Position slightly behind taillight mesh
                leftLight.position.z += 0.1;
                
                const rightLight = new THREE.PointLight(0xff0000, 0, 20, 2);
                rightLight.position.copy(rightTaillight.position);
                rightLight.position.z += 0.1;
                
                // No shadows for taillights to save performance
                leftLight.castShadow = false;
                rightLight.castShadow = false;
                
                // Add to car
                this.player.add(leftLight);
                this.player.add(rightLight);
                
                // Store references for toggling
                this.taillights.push(leftLight, rightLight);
                
                // Start with lights off
                leftLight.intensity = 0;
                rightLight.intensity = 0;
                
                // Add smaller lens flare for taillights
                this.addLensFlare(leftTaillight.position, 0xff0000, 0.5);
                this.addLensFlare(rightTaillight.position, 0xff0000, 0.5);
            }
            
            addLensFlare(position, color, scale = 1.0) {
                // Create a simple lens flare effect using a sprite
                const textureLoader = new THREE.TextureLoader();
                const flareTexture = textureLoader.load('https://threejs.org/examples/textures/lensflare/lensflare0.png');
                
                const flareMaterial = new THREE.SpriteMaterial({
                    map: flareTexture,
                    color: color,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    opacity: 0 // Start invisible until lights are turned on
                });
                
                const flare = new THREE.Sprite(flareMaterial);
                flare.position.copy(position);
                flare.scale.set(2 * scale, 2 * scale, 1 * scale);
                
                this.player.add(flare);
                
                // Store reference to the flare in the corresponding light
                if (color === 0xff0000) {
                    this.taillights.push({ flare: flare });
                } else {
                    this.headlights.push({ flare: flare });
                }
            }
            
            applyDriftPhysics(deltaTime) {
                // Gradually recover from drift when handbrake is released
                if (!this.handbrakeActive) {
                    // Restore traction gradually
                    this.rearTractionFactor = Math.min(1.0, this.rearTractionFactor + deltaTime * 2.0);
                    
                    // Dampen angular velocity (rotational momentum)
                    this.angularVelocity *= (1.0 - Math.min(1.0, deltaTime * 3.0));
                    
                    // Dampen lateral velocity more aggressively when not drifting
                    this.lateralVelocity *= (1.0 - Math.min(1.0, deltaTime * 5.0));
                } else {
                    // When handbrake is active, lateral velocity persists more
                    this.lateralVelocity *= (1.0 - Math.min(1.0, deltaTime * 0.5));
                    
                    // Angular velocity decreases more slowly
                    this.angularVelocity *= (1.0 - Math.min(1.0, deltaTime * 1.0));
                }
                
                // Apply tire smoke effects when drifting hard
                if (this.handbrakeActive && Math.abs(this.lateralVelocity) > 10 && Math.abs(this.playerVelocity) > 10) {
                    // Create tire smoke at rear wheels
                    this.createDriftSmoke();
                }
            }
            
            createDriftSmoke() {
                // Only create drift smoke occasionally to prevent overwhelming effects
                if (Math.random() < 0.2) {
                    // Get car's current rotation
                    const carAngle = this.player.rotation.y;
                    
                    // Calculate wheel positions (rear wheels)
                    const wheelBase = 2.0; // Distance between front and rear axles
                    const trackWidth = 1.6; // Distance between left and right wheels
                    
                    // Rear wheel positions relative to car center
                    const rearWheelZ = wheelBase / 2;
                    
                    // Calculate world positions for rear wheels
                    const leftRearWheelPos = new THREE.Vector3(
                        this.player.position.x - Math.sin(carAngle) * rearWheelZ - Math.sin(carAngle + Math.PI/2) * trackWidth/2,
                        0.3, // Slightly above ground
                        this.player.position.z - Math.cos(carAngle) * rearWheelZ - Math.cos(carAngle + Math.PI/2) * trackWidth/2
                    );
                    
                    const rightRearWheelPos = new THREE.Vector3(
                        this.player.position.x - Math.sin(carAngle) * rearWheelZ + Math.sin(carAngle + Math.PI/2) * trackWidth/2,
                        0.3, // Slightly above ground
                        this.player.position.z - Math.cos(carAngle) * rearWheelZ + Math.cos(carAngle + Math.PI/2) * trackWidth/2
                    );
                    
                    // Create smoke effect at each rear wheel
                    this.createSmokeParticles(leftRearWheelPos);
                    this.createSmokeParticles(rightRearWheelPos);
                }
            }
            
            createSmokeParticles(position) {
                // Parameters for smoke effect
                const smokeCount = 10 + Math.floor(Math.random() * 10);
                const smokeGroup = new THREE.Group();
                smokeGroup.position.copy(position);
                this.scene.add(smokeGroup);
                
                // Create individual smoke particles
                for (let i = 0; i < smokeCount; i++) {
                    // Random smoke direction in a circle
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 5;
                    
                    // Create larger particles for smoke
                    const smokeSize = 0.3 + Math.random() * 0.5;
                    const smokeGeometry = new THREE.PlaneGeometry(smokeSize, smokeSize);
                    
                    // Use white smoke for tire burn
                    const smokeMaterial = new THREE.MeshBasicMaterial({
                        color: 0xeeeeee,
                        transparent: true, 
                        opacity: 0.3 + Math.random() * 0.3
                    });
                    
                    const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
                    smoke.rotation.x = degToRad(-90); // Make it parallel to ground
                    smoke.castShadow = false;
                    smoke.receiveShadow = false;
                    
                    // Add to group
                    smokeGroup.add(smoke);
                    
                    // Random direction and velocity
                    smoke.userData = {
                        velocity: new THREE.Vector3(
                            Math.cos(angle) * speed,
                            0.8 + Math.random() * 2, // Upward velocity
                            Math.sin(angle) * speed
                        ),
                        rotation: Math.random() * 0.1,
                        created: Date.now(),
                        fadeTime: 1000 + Math.random() * 1000, // 1-2 seconds lifetime
                        size: smokeSize
                    };
                }
                
                // Track this smoke effect
                this.currentSparks.push({
                    group: smokeGroup,
                    created: Date.now(),
                    isSmoke: true
                });
            }
            
            createSkidmarks() {
                // Only create skidmarks when handbrake is active or drifting significantly
                if (!this.handbrakeActive && Math.abs(this.driftAngle) < 0.2) {
                    this.activeSkidmarks = false;
                    return;
                }
                
                const now = Date.now();
                const speedFactor = Math.abs(this.playerVelocity);
                
                // Skip at very low speeds
                if (speedFactor < 3) return;
                
                this.activeSkidmarks = true;
                
                // Throttle creation rate for performance - higher speeds get more frequent updates
                let interval = 100; // Base interval in ms
                if (speedFactor > 40) {
                    interval = 50;
                } else if (speedFactor > 20) {
                    interval = 70;
                }
                
                if (now - this.lastSkidmarkTime < interval) return;
                this.lastSkidmarkTime = now;
                
                // Calculate wheel positions
                const carAngle = this.player.rotation.y;
                const wheelBase = 2.0; // Distance between front and rear axles
                const trackWidth = 1.6; // Distance between left and right wheels
                
                // Rear wheel positions relative to car center
                const rearWheelZ = wheelBase / 2;
                
                // Calculate world positions for rear wheels
                const leftRearWheelPos = new THREE.Vector3(
                    this.player.position.x - Math.sin(carAngle) * rearWheelZ - Math.sin(carAngle + Math.PI/2) * trackWidth/2,
                    0.05, // Slightly above ground to prevent z-fighting
                    this.player.position.z - Math.cos(carAngle) * rearWheelZ - Math.cos(carAngle + Math.PI/2) * trackWidth/2
                );
                
                const rightRearWheelPos = new THREE.Vector3(
                    this.player.position.x - Math.sin(carAngle) * rearWheelZ + Math.sin(carAngle + Math.PI/2) * trackWidth/2,
                    0.05, // Slightly above ground
                    this.player.position.z - Math.cos(carAngle) * rearWheelZ + Math.cos(carAngle + Math.PI/2) * trackWidth/2
                );
                
                // Create skidmarks for left rear wheel
                if (this.lastWheelPositions.leftRear.length() > 0) {
                    const distanceMoved = leftRearWheelPos.distanceTo(this.lastWheelPositions.leftRear);
                    
                    if (distanceMoved > this.minSegmentLength) {
                        this.addSkidmarkSegment(this.lastWheelPositions.leftRear, leftRearWheelPos, speedFactor);
                        this.lastWheelPositions.leftRear.copy(leftRearWheelPos);
                    }
                } else {
                    // First time, just store the position
                    this.lastWheelPositions.leftRear.copy(leftRearWheelPos);
                }
                
                // Create skidmarks for right rear wheel
                if (this.lastWheelPositions.rightRear.length() > 0) {
                    const distanceMoved = rightRearWheelPos.distanceTo(this.lastWheelPositions.rightRear);
                    
                    if (distanceMoved > this.minSegmentLength) {
                        this.addSkidmarkSegment(this.lastWheelPositions.rightRear, rightRearWheelPos, speedFactor);
                        this.lastWheelPositions.rightRear.copy(rightRearWheelPos);
                    }
                } else {
                    // First time, just store the position
                    this.lastWheelPositions.rightRear.copy(rightRearWheelPos);
                }
                
                // Ensure skidmark sound is playing
                this.playHandbrakeSound();
            }
            
            addSkidmarkSegment(startPos, endPos, speedFactor) {
                // Calculate segment properties
                const segmentLength = startPos.distanceTo(endPos);
                const segmentWidth = 0.25; // Thinner width for two-track skidmarks
                
                // Calculate the direction from start to end
                const direction = new THREE.Vector3().subVectors(endPos, startPos).normalize();
                
                // Calculate the perpendicular direction (for width)
                const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x);
                
                // Create a custom geometry for the skidmark segment
                const geometry = new THREE.BufferGeometry();
                
                // Define the four corners of the segment
                const startLeft = new THREE.Vector3().copy(startPos).addScaledVector(perpendicular, segmentWidth/2);
                const startRight = new THREE.Vector3().copy(startPos).addScaledVector(perpendicular, -segmentWidth/2);
                const endLeft = new THREE.Vector3().copy(endPos).addScaledVector(perpendicular, segmentWidth/2);
                const endRight = new THREE.Vector3().copy(endPos).addScaledVector(perpendicular, -segmentWidth/2);
                
                // Create vertices array
                const vertices = new Float32Array([
                    // First triangle
                    startLeft.x, startLeft.y, startLeft.z,
                    endLeft.x, endLeft.y, endLeft.z,
                    startRight.x, startRight.y, startRight.z,
                    
                    // Second triangle
                    endLeft.x, endLeft.y, endLeft.z,
                    endRight.x, endRight.y, endRight.z,
                    startRight.x, startRight.y, startRight.z
                ]);
                
                // Set the vertices of the geometry
                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                
                // Create the mesh
                const segment = new THREE.Mesh(geometry, this.skidmarkMaterial);
                
                // Add to scene
                this.scene.add(segment);
                
                // Track the skidmark and manage the maximum number
                this.skidmarks.push({
                    mesh: segment,
                    created: Date.now(),
                    opacity: 0.95
                });
                
                // Remove oldest skidmark if we've exceeded the maximum
                if (this.skidmarks.length > this.maxSkidmarks) {
                    const oldest = this.skidmarks.shift();
                    this.scene.remove(oldest.mesh);
                }
            }
            
            updateSkidmarks(deltaTime) {
                const now = Date.now();
                
                // Update opacity of skidmarks - they fade out over time
                for (let i = this.skidmarks.length - 1; i >= 0; i--) {
                    const skidmark = this.skidmarks[i];
                    const age = (now - skidmark.created) / 1000; // Age in seconds
                    
                    // Skidmarks start fading after 5 seconds and disappear after 30 seconds
                    if (age > 30) {
                        this.scene.remove(skidmark.mesh);
                        this.skidmarks.splice(i, 1);
                        continue;
                    }
                    
                    // Start fading after 5 seconds
                    if (age > 5) {
                        const fadeProgress = (age - 5) / 25; // 0-1 over 25 seconds
                        const newOpacity = 0.9 * (1 - fadeProgress);
                        skidmark.mesh.material.opacity = newOpacity;
                    }
                }
            }
            
            performPhysicsUpdate() {
                // Skip if not in vehicle
                if (!this.isInVehicle) return;
                
                // Movement and steering inputs
                const accelerating = (this.keys['w'] || this.keys['arrowup']) && !this.keys['s'] && !this.keys['arrowdown'];
                const braking = (this.keys['s'] || this.keys['arrowdown']) && !this.keys['w'] && !this.keys['arrowup'];
                const steeringLeft = this.keys['a'] || this.keys['arrowleft'];
                const steeringRight = this.keys['d'] || this.keys['arrowright'];
                
                // Calculate steering angle
                let steeringAngle = 0;
                if (steeringLeft) steeringAngle = this.maxSteeringAngle;
                if (steeringRight) steeringAngle = -this.maxSteeringAngle;
                
                // Speed-sensitive steering
                const speedFactor = Math.min(Math.abs(this.playerVelocity) / 40, 1);
                // At high speeds, steering becomes less responsive
                steeringAngle *= (1 - 0.4 * speedFactor); // Reduced sensitivity reduction
                
                // Apply acceleration and braking
                if (accelerating) {
                    // Add acceleration proportional to current gear ratio
                    const accelerationForce = this.currentGear.acceleration * this.deltaTime;
                    this.playerVelocity += accelerationForce;
                    
                    // Counter-steer helps stabilize during drift but don't overdo it
                    if (this.handbrakeActive && Math.abs(this.driftAngle) > 0.3) {
                        // Apply some corrective force based on drift angle, but keep it subtle
                        this.angularVelocity -= this.driftAngle * 0.2 * this.deltaTime;
                    }
                } else if (braking) {
                    // Apply braking force
                    const brakingForce = 35 * this.deltaTime;
                    
                    if (this.playerVelocity > 0) {
                        this.playerVelocity = Math.max(0, this.playerVelocity - brakingForce);
                    } else {
                        this.playerVelocity = Math.min(0, this.playerVelocity + brakingForce);
                    }
                }
                
                // Apply automatic drag/rolling resistance (always slows down the car)
                const dragFactor = 3; // Base rolling resistance
                const drag = dragFactor * this.deltaTime;
                
                if (Math.abs(this.playerVelocity) > drag) {
                    this.playerVelocity -= Math.sign(this.playerVelocity) * drag;
                } else {
                    this.playerVelocity = 0;
                }
                
                // Maximum speed clamping
                this.playerVelocity = Math.min(this.playerVelocity, this.currentGear.maxSpeed);
                this.playerVelocity = Math.max(this.playerVelocity, -this.reverseMaxSpeed);
                
                // Front-wheel steering effect - front wheels maintain grip
                if (Math.abs(this.playerVelocity) > 1) {
                    // Calculate the front wheel steering effect based on speed
                    const steeringEffect = steeringAngle * (Math.abs(this.playerVelocity) * 0.02);
                    
                    // For realistic drifting, modify how steering affects the car when handbrake is active
                    if (this.handbrakeActive) {
                        // When handbrake is active, front wheels still steer but with reduced effect
                        // This simulates front wheels fighting against the sliding rear
                        this.angularVelocity += steeringEffect * this.deltaTime * 1.8;
                        
                        // Apply drift physics - powerful rotational and lateral forces
                        if (Math.abs(steeringAngle) > 0.01) {
                            // Direction of the turn
                            const turnDirection = Math.sign(steeringAngle);
                            
                            // The key physics for proper drifting with rear swing:
                            // 1. Strong continuous rotational force in the steering direction
                            // This makes the car keep rotating throughout the drift
                            const rotationForce = turnDirection * Math.abs(this.playerVelocity) * 0.03;
                            this.angularVelocity += rotationForce * this.deltaTime * 2;
                            
                            // 2. Continuous lateral force opposite to the turn direction
                            // This pushes the rear outward while the front continues in steering direction
                            const lateralForce = turnDirection * Math.abs(this.playerVelocity) * 0.03;
                            this.lateralVelocity -= lateralForce * this.deltaTime * 6;
                        }
                    } else {
                        // Normal steering - standard effect
                        this.angularVelocity += steeringEffect * this.deltaTime * 2.5;
                    }
                }
                
                // Apply traction - critical for drift behavior
                // Front wheels maintain high grip regardless of handbrake
                let currentFrontTraction = this.frontTractionFactor;
                let currentRearTraction = this.defaultRearTraction;
                
                // Very low rear traction when handbrake is active
                if (this.handbrakeActive) {
                    currentRearTraction = this.rearTractionFactor;
                } else if (this.rearTractionFactor < this.defaultRearTraction) {
                    // Gradually restore traction after handbrake is released
                    this.rearTractionFactor += this.deltaTime * 1.5;
                    this.rearTractionFactor = Math.min(this.rearTractionFactor, this.defaultRearTraction);
                    currentRearTraction = this.rearTractionFactor;
                }
                
                // Apply separate traction to front and rear
                // This is key: front maintains grip, rear loses grip
                if (this.handbrakeActive) {
                    // When handbrake is active, lateral velocity is affected differently by front/rear traction
                    // Front wheels try to grip and go in the direction they're pointing
                    // Rear wheels slide freely
                    // This weighted traction model is crucial for proper drifting
                    
                    // Rear-biased traction calculation (mostly influenced by rear wheels)
                    const rearBiasedTraction = Math.pow(currentRearTraction, this.deltaTime);
                    // Front-biased traction calculation (mostly influenced by front wheels)
                    const frontBiasedTraction = Math.pow(currentFrontTraction, this.deltaTime);
                    
                    // Overall lateral traction is biased toward rear (70% rear, 30% front)
                    // This means rear wheels have more influence during handbrake
                    const driftTraction = (rearBiasedTraction * 0.7) + (frontBiasedTraction * 0.3);
                    this.lateralVelocity *= driftTraction;
                } else {
                    // Normal driving - standard traction model
                    const normalTraction = Math.pow((currentFrontTraction + currentRearTraction) / 2, this.deltaTime);
                    this.lateralVelocity *= normalTraction;
                }
                
                // Different angular drag during handbrake for better rotation
                // Higher value means more rotation is preserved during drift
                const angularDragFactor = this.handbrakeActive ? 0.97 : 0.85;
                this.angularVelocity *= Math.pow(angularDragFactor, this.deltaTime);
                
                // Calculate car direction vector
                const carDirection = new THREE.Vector3(
                    Math.sin(this.player.rotation.y),
                    0,
                    Math.cos(this.player.rotation.y)
                );
                
                // Calculate lateral direction (perpendicular to car direction)
                const lateralDirection = new THREE.Vector3(
                    carDirection.z,
                    0,
                    -carDirection.x
                );
                
                // Update position based on forward and lateral velocities
                this.player.position.x += carDirection.x * this.playerVelocity * this.deltaTime;
                this.player.position.z += carDirection.z * this.playerVelocity * this.deltaTime;
                
                this.player.position.x += lateralDirection.x * this.lateralVelocity * this.deltaTime;
                this.player.position.z += lateralDirection.z * this.lateralVelocity * this.deltaTime;
                
                // Update rotation based on angular velocity
                this.player.rotation.y += this.angularVelocity * this.deltaTime;
                
                // Calculate drift angle (angle between velocity and car direction)
                // This is used for visual effects and gameplay feedback
                const velocityDirection = new THREE.Vector3(
                    carDirection.x * this.playerVelocity + lateralDirection.x * this.lateralVelocity,
                    0,
                    carDirection.z * this.playerVelocity + lateralDirection.z * this.lateralVelocity
                ).normalize();
                
                if (velocityDirection.length() > 0.1) {
                    const dot = carDirection.dot(velocityDirection);
                    const det = carDirection.x * velocityDirection.z - carDirection.z * velocityDirection.x;
                    this.driftAngle = Math.atan2(det, dot);
                } else {
                    this.driftAngle = 0;
                }
                
                // Car tilt effect based on lateral velocity and turning
                // During drift, car should lean away from the turn
                const tiltAmount = 0.15; // Maximum tilt in radians
                
                // Tilt based on lateral velocity and angular velocity
                // This creates the visual effect of weight transfer
                const lateralTilt = this.lateralVelocity * 0.3;
                const angularTilt = this.angularVelocity * 0.8;
                
                // Apply tilt for visual effect - combined effect gives realistic lean
                this.player.rotation.z = Math.max(-tiltAmount, Math.min(tiltAmount, lateralTilt + angularTilt));
                
                // Update camera to follow the car
                this.updateCamera();
                
                // Check for skidmarks
                this.createSkidmarks();
                
                // Collision detection with buildings and obstacles
                this.checkCollisions();
                
                // Emission of dust/dirt particles when drifting
                this.checkParticles();
                
                // Update sound effects based on speed and driving conditions
                this.updateSounds();
            }
            
            // Function to shoot a bullet
            shootBullet() {
                if (!this.pedestrian || !this.canShoot) return;
                
                // Reset shooting flag
                this.canShoot = false;
                
                // Count bullets for tracer rounds
                this.bulletCount++;
                const isTracer = this.bulletCount % this.tracerInterval === 0;
                
                // Get direction from pedestrian's rotation
                const direction = new THREE.Vector3(
                    Math.sin(this.pedestrian.rotation.y),
                    0,
                    Math.cos(this.pedestrian.rotation.y)
                );
                
                // Add small random spread for more realistic Uzi fire
                const spreadFactor = 0.04; // Slight bullet spread
                direction.x += (Math.random() - 0.5) * spreadFactor;
                direction.z += (Math.random() - 0.5) * spreadFactor;
                direction.normalize(); // Normalize after adding spread
                
                // Starting position (pedestrian's gun position)
                const startPos = this.pedestrian.position.clone();
                startPos.y = 1.4; // Shoulder height
                startPos.addScaledVector(direction, 0.8); // Move forward a bit
                
                // End position (where bullet will reach at end of lifetime)
                const endPos = startPos.clone().addScaledVector(direction, 10); // Longer line for visibility
                
                // Create line geometry for the bullet - using BufferGeometry for performance
                const bulletGeometry = new THREE.BufferGeometry();
                const vertices = new Float32Array([
                    startPos.x, startPos.y, startPos.z,
                    endPos.x, endPos.y, endPos.z
                ]);
                
                bulletGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                
                // Create material - brighter for tracers
                const bulletMaterial = new THREE.LineBasicMaterial({ 
                    color: isTracer ? 0xff4500 : 0xffff00,
                    linewidth: 3 // Note: linewidth only works in Firefox
                });
                
                // Create the line
                const bullet = new THREE.Line(bulletGeometry, bulletMaterial);
                
                // Add to scene
                this.scene.add(bullet);
                
                // Simple muzzle flash - just a light without complex geometry
                this.createSimpleMuzzleFlash(startPos.clone(), direction.clone());
                
                // Play simpler gun sound
                this.playSimpleGunSound();
                
                // Add bullet to bullets array with its properties
                this.bullets.push({
                    mesh: bullet,
                    direction: direction,
                    velocity: direction.clone().multiplyScalar(this.bulletSpeed),
                    spawnTime: Date.now(),
                    isTracer: isTracer,
                    // Store actual start/end vectors for movement calculations
                    startVector: new THREE.Vector3(startPos.x, startPos.y, startPos.z),
                    endVector: new THREE.Vector3(endPos.x, endPos.y, endPos.z)
                });
                
                // Re-enable shooting after cooldown
                setTimeout(() => {
                    this.canShoot = true;
                    // Immediately try to shoot again if key is still pressed
                    if (this.keysPressed['Space'] && !this.isInVehicle && this.pedestrian) {
                        this.shootBullet();
                    }
                }, 85); // 85ms cooldown for Uzi-like fire rate (approx 700 RPM)
            }
            
            // Simplified muzzle flash for better performance
            createSimpleMuzzleFlash(position, direction) {
                // Just use a point light for the flash - much more efficient
                const muzzleFlash = new THREE.PointLight(0xffff00, 1, 3);
                position.addScaledVector(direction, 0.2); // Position slightly in front
                muzzleFlash.position.copy(position);
                
                // Add to scene
                this.scene.add(muzzleFlash);
                
                // Remove after a short duration
                setTimeout(() => {
                    this.scene.remove(muzzleFlash);
                }, 30); // Shorter duration for better performance
            }
            
            // Simplified gun sound with fewer components
            playSimpleGunSound() {
                // Use a simplified sound that requires less processing
                try {
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    // Only create two quick sounds instead of five
                    const ctx = this.audioContext;
                    
                    // Create oscillator for the main "crack" sound
                    const oscillator = ctx.createOscillator();
                    oscillator.type = 'square';
                    oscillator.frequency.value = 1800; // High pitched crack
                    
                    // Create gain node for volume control
                    const gainNode = ctx.createGain();
                    gainNode.gain.setValueAtTime(0.2, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.08);
                    
                    // Connect and play
                    oscillator.connect(gainNode);
                    gainNode.connect(ctx.destination);
                    
                    oscillator.start();
                    oscillator.stop(ctx.currentTime + 0.08);
                } catch (e) {
                    // Fail silently if audio issues occur - don't block the game
                    console.error("Audio error:", e);
                }
            }
            
            // Function to update bullets
            updateBullets(deltaTime) {
                // Current time for removing old bullets
                const currentTime = Date.now();
                
                // Update each bullet
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    
                    // Move bullet vectors
                    bullet.startVector.addScaledVector(bullet.velocity, deltaTime);
                    bullet.endVector.addScaledVector(bullet.velocity, deltaTime);
                    
                    // Update the line geometry to match new positions
                    const positions = bullet.mesh.geometry.attributes.position.array;
                    
                    // Update start position (first vertex)
                    positions[0] = bullet.startVector.x;
                    positions[1] = bullet.startVector.y;
                    positions[2] = bullet.startVector.z;
                    
                    // Update end position (second vertex)
                    positions[3] = bullet.endVector.x;
                    positions[4] = bullet.endVector.y;
                    positions[5] = bullet.endVector.z;
                    
                    // Flag the buffer for update
                    bullet.mesh.geometry.attributes.position.needsUpdate = true;
                    
                    // Check if bullet lifetime is over
                    if (currentTime - bullet.spawnTime > this.bulletLifetime) {
                        // Remove bullet from scene
                        this.scene.remove(bullet.mesh);
                        
                        // Remove bullet from array
                        this.bullets.splice(i, 1);
                        continue;
                    }
                    
                    // Check for collisions with vehicles
                    if (this.player && !this.isInVehicle && this.vehicleCanBeDamaged) {
                        // IMPROVED: Check collision along the entire bullet line not just the endpoint
                        // This fixes the issue where close-range shots weren't registering
                        
                        // Get bullet line start and end points
                        const lineStart = bullet.startVector.clone();
                        const lineEnd = bullet.endVector.clone();
                        
                        // Calculate bullet line direction and length
                        const bulletDir = new THREE.Vector3().subVectors(lineEnd, lineStart).normalize();
                        const bulletLength = lineStart.distanceTo(lineEnd);
                        
                        // Check multiple points along the bullet's path (not just the tip)
                        const checkPoints = 5; // Check 5 points along the bullet's path
                        let hitCar = false;
                        
                        for (let p = 0; p <= checkPoints; p++) {
                            // Get point at different positions along the bullet line
                            const fraction = p / checkPoints;
                            const checkPoint = new THREE.Vector3().copy(lineStart).addScaledVector(bulletDir, bulletLength * fraction);
                            
                            // Check distance from this point to the car
                            const distance = checkPoint.distanceTo(this.player.position);
                            
                            // If bullet is close to vehicle
                            if (distance < 2.5) { // Vehicle collision radius
                                // Create impact effect
                                this.createBulletVehicleImpact(checkPoint);
                                
                                // Damage vehicle
                                this.damageVehicle(this.damagePerBullet);
                                
                                // Remove bullet from scene and array
                                this.scene.remove(bullet.mesh);
                                this.bullets.splice(i, 1);
                                hitCar = true;
                                break;
                            }
                        }
                        
                        if (hitCar) continue;
                    }
                    
                    // Check for collisions with buildings - use the front point of the bullet
                    const bulletFrontX = bullet.endVector.x;
                    const bulletFrontZ = bullet.endVector.z;
                    
                    for (const obj of this.collidableObjects) {
                        if (obj.type === 'building') {
                            // Simple collision check using the front of the bullet line
                            const halfWidth = obj.width / 2;
                            const halfDepth = obj.depth / 2;
                            const minX = obj.position.x - halfWidth;
                            const maxX = obj.position.x + halfWidth;
                            const minZ = obj.position.z - halfDepth;
                            const maxZ = obj.position.z + halfDepth;
                            
                            if (bulletFrontX > minX && bulletFrontX < maxX &&
                                bulletFrontZ > minZ && bulletFrontZ < maxZ) {
                                // Create spark effect at collision point
                                this.createSimpleBulletImpact(
                                    new THREE.Vector3(bulletFrontX, bullet.endVector.y, bulletFrontZ)
                                );
                                
                                // Remove bullet from scene
                                this.scene.remove(bullet.mesh);
                                
                                // Remove bullet from array
                                this.bullets.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
            }
            
            // Simplified bullet impact effect
            createSimpleBulletImpact(position) {
                // Use a simple point light for the impact spark
                const impactLight = new THREE.PointLight(0xffff00, 0.8, 2);
                impactLight.position.copy(position);
                this.scene.add(impactLight);
                
                // Remove after a short duration
                setTimeout(() => {
                    this.scene.remove(impactLight);
                }, 100);
            }
            
            // Override the old complex functions to use simplified versions
            createMuzzleFlash(position, direction) {
                this.createSimpleMuzzleFlash(position, direction);
            }
            
            playGunSound() {
                this.playSimpleGunSound();
            }
            
            createBulletImpact(position) {
                this.createSimpleBulletImpact(position);
            }
            
            // Initialize the shooting system
            initShooting() {
                // Initialize properties for the shooting system
                this.bullets = [];
                this.bulletSpeed = 120; // Faster bullets for Uzi
                this.bulletLifetime = 1500; // 1.5 seconds lifetime
                this.canShoot = true; // Flag to control shooting rate
                this.bulletCount = 0;
                this.tracerInterval = 4; // Every 4th bullet is a tracer
            }
            
            // Handle player movement
            handleMovement(deltaTime) {
                // If in vehicle, control vehicle. Otherwise, control pedestrian
                if (this.isInVehicle) {
                    this.updateVehicle(deltaTime);
                } else if (this.pedestrian) {
                    this.updatePedestrian(deltaTime);
                }
            }
            
            // Check if player is on foot (not in vehicle)
            isPlayerOnFoot() {
                return !this.isInVehicle && this.pedestrian !== null;
            }
            
            // Function to create a vehicle explosion effect
            createVehicleExplosion() {
                if (this.vehicleIsExploding) return; // Prevent multiple explosions
                
                this.vehicleIsExploding = true;
                this.vehicleCanBeDamaged = false;
                
                // Store camera initial position for shake effect
                const originalCameraPosition = this.camera.position.clone();
                
                // Get vehicle position
                const vehiclePosition = this.player.position.clone();
                
                // PHASE 1: Initial explosion flash - BIGGER and BRIGHTER
                const explosionLight = new THREE.PointLight(0xffbb00, 25, 80, 2); // Even brighter and larger radius
                explosionLight.position.copy(vehiclePosition);
                explosionLight.position.y += 2;
                this.scene.add(explosionLight);
                
                // PHASE 2: Primary explosion particles - MORE particles, LARGER, WIDER SPREAD
                const particleCount = 500; // Significantly more particles
                const explosionGeometry = new THREE.BufferGeometry();
                const explosionMaterial = new THREE.PointsMaterial({
                    color: 0xff5500,
                    size: 1.5, // Larger particles
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 1.0
                });
                
                const positions = new Float32Array(particleCount * 3);
                const velocities = [];
                const sizes = new Float32Array(particleCount);
                const colors = [];
                const particleLifetimes = [];
                
                // Create color array for flame-like gradient
                const particleColors = [
                    new THREE.Color(0xffff00), // Bright yellow
                    new THREE.Color(0xff8800), // Orange
                    new THREE.Color(0xff4400), // Dark orange
                    new THREE.Color(0xff0000), // Red
                    new THREE.Color(0xbb0000)  // Dark red
                ];
                
                for (let i = 0; i < particleCount; i++) {
                    // Start at explosion center with wider random offset
                    positions[i * 3] = vehiclePosition.x + (Math.random() - 0.5) * 1.0; // Wider initial spread
                    positions[i * 3 + 1] = vehiclePosition.y + Math.random() * 1.0;     // Higher initial position
                    positions[i * 3 + 2] = vehiclePosition.z + (Math.random() - 0.5) * 1.0; // Wider initial spread
                    
                    // Explosion force vector - FASTER and more spread
                    const angle = Math.random() * Math.PI * 2;
                    const height = Math.random() * Math.PI - Math.PI/2; // Angle from horizontal
                    const speed = 15 + Math.random() * 35; // Even higher speeds for bigger explosion
                    
                    // Convert spherical to cartesian coordinates for more realistic 3D explosion
                    const velocity = new THREE.Vector3(
                        Math.cos(angle) * Math.cos(height) * speed,
                        Math.sin(height) * speed,
                        Math.sin(angle) * Math.cos(height) * speed
                    );
                    
                    velocities.push(velocity);
                    
                    // Random size for particles - larger
                    sizes[i] = 0.8 + Math.random() * 1.8; // Even larger particles
                    
                    // Random color from our gradient
                    const colorIndex = Math.floor(Math.random() * particleColors.length);
                    colors.push(particleColors[colorIndex].r, particleColors[colorIndex].g, particleColors[colorIndex].b);
                    
                    // Very short lifetimes for faster fading
                    particleLifetimes.push(0.2 + Math.random() * 0.8); // Much shorter lifetime (0.2-1.0 seconds)
                }
                
                explosionGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                explosionGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                // Add colors attribute for better visual effect
                explosionGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                explosionMaterial.vertexColors = true;
                
                const explosionParticles = new THREE.Points(explosionGeometry, explosionMaterial);
                this.scene.add(explosionParticles);
                
                // PHASE 3: Fire effect - more sprites, much bigger initially, but fades faster
                const fireCount = 60; // Even more fire sprites
                const fireParticles = new THREE.Group();
                const fireTexture = this.createFireTexture();
                
                const fireSprites = [];
                const fireSizes = [];
                const firePositions = [];
                const fireVelocities = [];
                const fireRotationSpeeds = [];
                
                for (let i = 0; i < fireCount; i++) {
                    const fireSpriteMaterial = new THREE.SpriteMaterial({
                        map: fireTexture,
                        color: 0xffff80,
                        transparent: true,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const sprite = new THREE.Sprite(fireSpriteMaterial);
                    const size = 3.0 + Math.random() * 5.0; // Significantly larger flames
                    sprite.scale.set(size, size, 1.0);
                    
                    // Random position near explosion center - much wider spread
                    const pos = new THREE.Vector3(
                        vehiclePosition.x + (Math.random() - 0.5) * 6, // Double spread
                        vehiclePosition.y + Math.random() * 1.5,      // Higher position
                        vehiclePosition.z + (Math.random() - 0.5) * 6  // Double spread
                    );
                    sprite.position.copy(pos);
                    
                    // Velocity - mainly upward with some spread - faster
                    const vel = new THREE.Vector3(
                        (Math.random() - 0.5) * 6,
                        6 + Math.random() * 12, // Much faster upward
                        (Math.random() - 0.5) * 6
                    );
                    
                    fireSprites.push(sprite);
                    fireSizes.push(size);
                    firePositions.push(pos);
                    fireVelocities.push(vel);
                    fireRotationSpeeds.push((Math.random() - 0.5) * 6); // Faster rotation
                    
                    fireParticles.add(sprite);
                }
                
                this.scene.add(fireParticles);
                
                // PHASE 4: Smoke particles - begins immediately, more intense, fades faster
                const smokeCount = 70; // More smoke particles
                const smokeGroup = new THREE.Group();
                const smokeTexture = this.createSmokeTexture();
                
                const smokeSprites = [];
                const smokeScales = [];
                const smokePositions = [];
                const smokeVelocities = [];
                const smokeRotationSpeeds = [];
                const smokeLifetimes = [];
                const smokeStartTimes = [];
                
                for (let i = 0; i < smokeCount; i++) {
                    const smokeMaterial = new THREE.SpriteMaterial({
                        map: smokeTexture,
                        color: 0x222222,
                        transparent: true,
                        opacity: 0.8 // More opaque initially
                    });
                    
                    const sprite = new THREE.Sprite(smokeMaterial);
                    const scale = 4 + Math.random() * 6; // Even larger scale for smoke
                    sprite.scale.set(scale, scale, 1.0);
                    
                    // Start position - much wider spread
                    const startDelay = Math.random() * 0.3; // Very short delays
                    const pos = new THREE.Vector3(
                        vehiclePosition.x + (Math.random() - 0.5) * 8, // Wider spread
                        vehiclePosition.y + Math.random() * 2.0,      // Higher initial position
                        vehiclePosition.z + (Math.random() - 0.5) * 8  // Wider spread
                    );
                    sprite.position.copy(pos);
                    
                    // Velocity - faster upward drift
                    const vel = new THREE.Vector3(
                        (Math.random() - 0.5) * 4,
                        3 + Math.random() * 6, // Even faster rise
                        (Math.random() - 0.5) * 4
                    );
                    
                    smokeSprites.push(sprite);
                    smokeScales.push(scale);
                    smokePositions.push(pos);
                    smokeVelocities.push(vel);
                    smokeRotationSpeeds.push((Math.random() - 0.5) * 1.5); // Faster rotation
                    smokeLifetimes.push(1.5 + Math.random() * 1.5); // Much shorter life (1.5-3 seconds)
                    smokeStartTimes.push(startDelay);
                    
                    // Start immediately visible
                    smokeMaterial.opacity = 0.5;
                    
                    smokeGroup.add(sprite);
                }
                
                this.scene.add(smokeGroup);
                
                // PHASE 5: Debris particles - more and larger, flung further
                const debrisCount = 40; // More debris pieces
                const debrisGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.6); // Larger debris
                const debrisMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    roughness: 0.7,
                    metalness: 0.5
                });
                
                const debrisMeshes = [];
                const debrisVelocities = [];
                const debrisRotations = [];
                
                for (let i = 0; i < debrisCount; i++) {
                    const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
                    debris.position.copy(vehiclePosition);
                    debris.position.y += 0.5; // Start slightly above car
                    
                    // Random velocity - much stronger and faster
                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 30, // 50% higher horizontal speed
                        12 + Math.random() * 20,    // Much higher initial upward velocity
                        (Math.random() - 0.5) * 30  // 50% higher horizontal speed
                    );
                    
                    // Random rotation speed - faster
                    const rotation = new THREE.Vector3(
                        Math.random() * 15,
                        Math.random() * 15,
                        Math.random() * 15
                    );
                    
                    debrisMeshes.push(debris);
                    debrisVelocities.push(velocity);
                    debrisRotations.push(rotation);
                    
                    this.scene.add(debris);
                }
                
                // Play explosion sound with more dramatic effect
                this.playEnhancedExplosionSound();
                
                // Apply damage/deformation effect to vehicle
                if (this.player) {
                    // Find all meshes in the player group and modify them
                    this.player.traverse((child) => {
                        if (child.isMesh) {
                            // Darken and add burn effect
                            if (child.material) {
                                child.material.color.set(0x222222);
                                child.material.emissive.set(0x330000);
                                child.material.roughness = 0.9; // More rough for burned look
                                
                                // Add more extreme deformation
                                if (child.geometry) {
                                    const positions = child.geometry.attributes.position.array;
                                    for (let i = 0; i < positions.length; i += 3) {
                                        // Apply more extreme random deformation
                                        positions[i] += (Math.random() - 0.5) * 0.6; // 50% more deformation
                                        positions[i+1] += (Math.random() - 0.5) * 0.6;
                                        positions[i+2] += (Math.random() - 0.5) * 0.6;
                                    }
                                    child.geometry.attributes.position.needsUpdate = true;
                                }
                            }
                        }
                    });
                }
                
                // Camera shake effect - stronger but shorter
                let shakeIntensity = 1.2; // Higher initial shake intensity
                let shakeDuration = 1.0; // Shorter duration in seconds
                let shakeStartTime = Date.now();
                
                // Animation loop for the explosion - ADJUSTED TIMING
                let explosionTime = 0;
                const explosionDuration = 3.5; // Slightly longer duration, but with much faster fade
                
                const updateExplosion = (delta) => {
                    explosionTime += delta;
                    
                    // Apply camera shake if within shake duration
                    if ((Date.now() - shakeStartTime) / 1000 < shakeDuration) {
                        // Calculate remaining shake intensity (decreases more quickly)
                        const remainingShake = shakeIntensity * Math.pow(1 - (Date.now() - shakeStartTime) / (shakeDuration * 1000), 2);
                        
                        // Apply random offset to camera (larger shake)
                        this.camera.position.x = originalCameraPosition.x + (Math.random() - 0.5) * remainingShake * 3;
                        this.camera.position.z = originalCameraPosition.z + (Math.random() - 0.5) * remainingShake * 3;
                        this.camera.position.y = originalCameraPosition.y + (Math.random() - 0.5) * remainingShake * 1.5;
                    } else {
                        // Reset camera position after shake
                        this.camera.position.copy(originalCameraPosition);
                    }
                    
                    // Update primary explosion particles - FASTER FADE
                    const positions = explosionParticles.geometry.attributes.position.array;
                    const sizes = explosionParticles.geometry.attributes.size.array;
                    
                    for (let i = 0; i < particleCount; i++) {
                        // Apply velocity with stronger gravity
                        velocities[i].y -= 20.0 * delta; // Higher gravity for faster fall
                        
                        // Faster slowdown (air resistance)
                        velocities[i].x *= 0.92;
                        velocities[i].y *= 0.92;
                        velocities[i].z *= 0.92;
                        
                        // Update position
                        positions[i * 3] += velocities[i].x * delta;
                        positions[i * 3 + 1] += velocities[i].y * delta;
                        positions[i * 3 + 2] += velocities[i].z * delta;
                        
                        // Shrink particles MUCH faster
                        if (explosionTime < particleLifetimes[i]) {
                            sizes[i] *= 0.93; // Faster shrink
                        } else {
                            sizes[i] = 0; // Hide when lifetime is over
                        }
                    }
                    
                    // Overall opacity fade - much faster
                    if (explosionTime > 0.4) { // Start fading after 0.4 seconds
                        const particleFade = Math.max(0, 1 - ((explosionTime - 0.4) / 0.8)); // Fade out over 0.8 seconds
                        explosionMaterial.opacity = particleFade;
                    }
                    
                    // Update buffers
                    explosionParticles.geometry.attributes.position.needsUpdate = true;
                    explosionParticles.geometry.attributes.size.needsUpdate = true;
                    
                    // Update fire sprites - fade MUCH faster
                    for (let i = 0; i < fireSprites.length; i++) {
                        const sprite = fireSprites[i];
                        
                        // Rise and slow down faster
                        fireVelocities[i].y -= 1.5 * delta; // Faster deceleration
                        fireVelocities[i].x *= 0.85; // Faster lateral slowdown
                        fireVelocities[i].z *= 0.85;
                        
                        sprite.position.x += fireVelocities[i].x * delta;
                        sprite.position.y += fireVelocities[i].y * delta;
                        sprite.position.z += fireVelocities[i].z * delta;
                        
                        // Rotate sprite faster
                        sprite.material.rotation += fireRotationSpeeds[i] * delta;
                        
                        // Fade out MUCH more quickly
                        const fadeStart = 0.2; // Start fading almost immediately
                        if (explosionTime > fadeStart) {
                            const fadeFactor = 1.0 - Math.min(1.0, (explosionTime - fadeStart) / 0.5); // Fade over just 0.5 seconds
                            sprite.material.opacity = fadeFactor;
                            sprite.scale.x = fireSizes[i] * fadeFactor;
                            sprite.scale.y = fireSizes[i] * fadeFactor;
                        }
                    }
                    
                    // Update smoke sprites - faster expansion but quicker fade
                    for (let i = 0; i < smokeSprites.length; i++) {
                        const sprite = smokeSprites[i];
                        const adjustedTime = explosionTime - smokeStartTimes[i];
                        
                        if (adjustedTime > 0) {
                            // Move smoke upward with faster physics
                            smokeVelocities[i].y *= 0.94; // Slightly faster deceleration
                            sprite.position.x += smokeVelocities[i].x * delta;
                            sprite.position.y += smokeVelocities[i].y * delta;
                            sprite.position.z += smokeVelocities[i].z * delta;
                            
                            // Rotate sprite
                            sprite.material.rotation += smokeRotationSpeeds[i] * delta;
                            
                            // Fade in faster, then out faster
                            const fadeInTime = 0.1; // Nearly instant fade in
                            const lifeTime = smokeLifetimes[i];
                            
                            if (adjustedTime < fadeInTime) {
                                // Fade in faster
                                sprite.material.opacity = adjustedTime / fadeInTime * 0.8;
                            } else if (adjustedTime > lifeTime - 0.5) {
                                // Fade out in last 0.5 second (was 1.0)
                                sprite.material.opacity = 0.8 * (1.0 - (adjustedTime - (lifeTime - 0.5)) / 0.5);
                            }
                            
                            // Expand smoke faster
                            const expandFactor = Math.min(1.0 + adjustedTime * 1.5, 4.0); // Even faster expansion
                            sprite.scale.x = smokeScales[i] * expandFactor;
                            sprite.scale.y = smokeScales[i] * expandFactor;
                        }
                    }
                    
                    // Update debris particles with faster physics
                    for (let i = 0; i < debrisMeshes.length; i++) {
                        const debris = debrisMeshes[i];
                        
                        // Apply stronger gravity
                        debrisVelocities[i].y -= 25.0 * delta; // Stronger gravity
                        
                        // Update position
                        debris.position.x += debrisVelocities[i].x * delta;
                        debris.position.y += debrisVelocities[i].y * delta;
                        debris.position.z += debrisVelocities[i].z * delta;
                        
                        // Update rotation - faster
                        debris.rotation.x += debrisRotations[i].x * delta;
                        debris.rotation.y += debrisRotations[i].y * delta;
                        debris.rotation.z += debrisRotations[i].z * delta;
                        
                        // Ground collision
                        if (debris.position.y < 0) {
                            debris.position.y = 0;
                            debrisVelocities[i].y = -debrisVelocities[i].y * 0.2; // Less bounce
                            debrisVelocities[i].x *= 0.6; // More friction
                            debrisVelocities[i].z *= 0.6;
                            
                            // Stop very small bounces
                            if (Math.abs(debrisVelocities[i].y) < 3.0) {
                                debrisVelocities[i].y = 0;
                            }
                        }
                    }
                    
                    // Fade explosion light - much faster, brighter initial flash
                    if (explosionTime < 0.08) {
                        explosionLight.intensity = 25; // Full intensity for a very short time
                    } else if (explosionTime < 0.25) {
                        explosionLight.intensity = 25 * (1 - (explosionTime - 0.08) / 0.17);
                    } else {
                        explosionLight.intensity = 0;
                    }
                    
                    // Continue animation if still within duration
                    if (explosionTime < explosionDuration) {
                        requestAnimationFrame((timestamp) => {
                            const newDelta = Math.min(0.1, timestamp - lastTimestamp) / 1000;
                            lastTimestamp = timestamp;
                            updateExplosion(newDelta);
                        });
                    } else {
                        // Clean up
                        this.scene.remove(explosionParticles);
                        this.scene.remove(fireParticles);
                        this.scene.remove(smokeGroup);
                        this.scene.remove(explosionLight);
                        
                        // Remove debris
                        for (const debris of debrisMeshes) {
                            this.scene.remove(debris);
                        }
                        
                        // Reset camera position
                        this.camera.position.copy(originalCameraPosition);
                        
                        // Reset vehicle health after explosion animation
                        setTimeout(() => {
                            this.resetVehicleAfterExplosion();
                        }, 500); // Short delay before respawning
                    }
                };
                
                // Start animation
                let lastTimestamp = performance.now();
                requestAnimationFrame((timestamp) => {
                    lastTimestamp = timestamp;
                    updateExplosion(0.016); // Start with a small delta
                });
            }
            
            // Create a circular texture for fire particles
            createFireTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                
                // Create radial gradient
                const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.3, 'rgba(255, 200, 0, 0.8)');
                gradient.addColorStop(0.7, 'rgba(255, 50, 0, 0.5)');
                gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                
                context.fillStyle = gradient;
                context.fillRect(0, 0, 64, 64);
                
                const texture = new THREE.CanvasTexture(canvas);
                return texture;
            }
            
            // Create a smoke texture
            createSmokeTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                
                // Create radial gradient for smoke
                const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
                gradient.addColorStop(0, 'rgba(150, 150, 150, 0.9)');
                gradient.addColorStop(0.5, 'rgba(100, 100, 100, 0.5)');
                gradient.addColorStop(1, 'rgba(50, 50, 50, 0)');
                
                context.fillStyle = gradient;
                context.fillRect(0, 0, 64, 64);
                
                // Add some noise to the smoke texture
                for (let i = 0; i < 400; i++) {
                    const x = Math.random() * 64;
                    const y = Math.random() * 64;
                    const radius = Math.random() * 2;
                    
                    context.beginPath();
                    context.arc(x, y, radius, 0, Math.PI * 2);
                    context.fillStyle = `rgba(200, 200, 200, ${Math.random() * 0.2})`;
                    context.fill();
                }
                
                const texture = new THREE.CanvasTexture(canvas);
                return texture;
            }
            
            // Enhanced explosion sound
            playEnhancedExplosionSound() {
                try {
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    const ctx = this.audioContext;
                    
                    // 1. Initial blast sound - layered noise bursts
                    const createBlastSound = () => {
                        // Create burst noise
                        const burstSize = ctx.sampleRate * 0.7; // Longer duration
                        const burstBuffer = ctx.createBuffer(1, burstSize, ctx.sampleRate);
                        const burstData = burstBuffer.getChannelData(0);
                        
                        // Fill with shaped noise - more complex envelope
                        for (let i = 0; i < burstSize; i++) {
                            const t = i / burstSize;
                            // Multi-stage envelope for more realistic explosion
                            let envelope;
                            if (t < 0.1) {
                                // Sharp attack
                                envelope = t * 10;
                            } else if (t < 0.3) {
                                // Initial decay
                                envelope = 1.0 - 0.3 * ((t - 0.1) / 0.2);
                            } else {
                                // Long tail
                                envelope = 0.7 * Math.exp(-3 * (t - 0.3));
                            }
                            
                            // Add some low-frequency modulation for rumble
                            const rumble = 0.2 * Math.sin(t * 20);
                            
                            burstData[i] = (Math.random() * 2 - 1) * envelope + rumble * envelope;
                        }
                        
                        const blastSource = ctx.createBufferSource();
                        blastSource.buffer = burstBuffer;
                        
                        // Create multi-band processing for more realistic explosion
                        // Low-end boost
                        const lowpass = ctx.createBiquadFilter();
                        lowpass.type = 'lowpass';
                        lowpass.frequency.value = 200;
                        lowpass.Q.value = 1.0;
                        
                        // Mid-range presence
                        const bandpass = ctx.createBiquadFilter();
                        bandpass.type = 'bandpass';
                        bandpass.frequency.value = 800;
                        bandpass.Q.value = 0.8;
                        
                        // High-end air/debris sounds
                        const highpass = ctx.createBiquadFilter();
                        highpass.type = 'highpass';
                        highpass.frequency.value = 3000;
                        highpass.Q.value = 0.5;
                        
                        // Gain nodes for multi-band mixing
                        const lowGain = ctx.createGain();
                        lowGain.gain.value = 0.7;
                        
                        const midGain = ctx.createGain();
                        midGain.gain.value = 0.3;
                        
                        const highGain = ctx.createGain();
                        highGain.gain.value = 0.2;
                        
                        // Master gain
                        const masterGain = ctx.createGain();
                        masterGain.gain.value = 0.7;
                        
                        // Compression for that explosive punch
                        const compressor = ctx.createDynamicsCompressor();
                        compressor.threshold.value = -10;
                        compressor.knee.value = 10;
                        compressor.ratio.value = 12;
                        compressor.attack.value = 0.003;
                        compressor.release.value = 0.25;
                        
                        // Connect multi-band path
                        blastSource.connect(lowpass);
                        blastSource.connect(bandpass);
                        blastSource.connect(highpass);
                        
                        lowpass.connect(lowGain);
                        bandpass.connect(midGain);
                        highpass.connect(highGain);
                        
                        lowGain.connect(masterGain);
                        midGain.connect(masterGain);
                        highGain.connect(masterGain);
                        
                        masterGain.connect(compressor);
                        compressor.connect(ctx.destination);
                        
                        return blastSource;
                    };
                    
                    // 2. Deep rumble/sub bass
                    const createRumble = () => {
                        const oscillator = ctx.createOscillator();
                        oscillator.type = 'sine';
                        oscillator.frequency.value = 40; // Very low frequency
                        
                        const gainNode = ctx.createGain();
                        gainNode.gain.setValueAtTime(0, ctx.currentTime);
                        gainNode.gain.linearRampToValueAtTime(0.8, ctx.currentTime + 0.1); // Quick ramp up
                        gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 3.0); // Long fade out
                        
                        // Add slight pitch drop for more realism
                        oscillator.frequency.setValueAtTime(60, ctx.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(30, ctx.currentTime + 3.0);
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(ctx.destination);
                        
                        return oscillator;
                    };
                    
                    // 3. Secondary crackle/debris sounds slightly delayed
                    const createCrackle = () => {
                        const bufferSize = ctx.sampleRate * 2; // 2 seconds of crackle
                        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                        const data = buffer.getChannelData(0);
                        
                        // Generate random crackle that gets less frequent over time
                        for (let i = 0; i < bufferSize; i++) {
                            const t = i / bufferSize;
                            // Random crackle with decreasing frequency
                            if (Math.random() < 0.01 * (1 - t)) {
                                // Create short crackle that lasts a few samples
                                const crackleLength = Math.floor(Math.random() * 100) + 50;
                                const amplitude = Math.random() * 0.5;
                                
                                for (let j = 0; j < crackleLength && (i + j) < bufferSize; j++) {
                                    // Exponential decay for each crackle
                                    const decay = Math.exp(-j / (crackleLength * 0.3));
                                    data[i + j] = (Math.random() * 2 - 1) * amplitude * decay;
                                }
                                
                                // Skip ahead
                                i += crackleLength;
                            } else {
                                data[i] = 0;
                            }
                        }
                        
                        const crackleSource = ctx.createBufferSource();
                        crackleSource.buffer = buffer;
                        
                        const highpassFilter = ctx.createBiquadFilter();
                        highpassFilter.type = 'highpass';
                        highpassFilter.frequency.value = 2000;
                        
                        const gainNode = ctx.createGain();
                        gainNode.gain.value = 0.3;
                        
                        crackleSource.connect(highpassFilter);
                        highpassFilter.connect(gainNode);
                        gainNode.connect(ctx.destination);
                        
                        return {
                            source: crackleSource,
                            start: function(time) {
                                this.source.start(time);
                            }
                        };
                    };
                    
                    // Play all explosion components
                    const blastSound = createBlastSound();
                    blastSound.start();
                    
                    const rumble = createRumble();
                    rumble.start();
                    
                    // Delayed crackle
                    const crackle = createCrackle();
                    setTimeout(() => {
                        crackle.start(ctx.currentTime);
                    }, 100);
                    
                } catch (e) {
                    console.error("Audio error:", e);
                }
            }
            
            // Function to create bullet impact effect on vehicle
            createBulletVehicleImpact(position) {
                // Small spark
                const impactLight = new THREE.PointLight(0xffff00, 0.6, 1.5);
                impactLight.position.copy(position);
                this.scene.add(impactLight);
                
                // Bullet hole effect can be added here if desired
                
                // Remove after a short duration
                setTimeout(() => {
                    this.scene.remove(impactLight);
                }, 100);
                
                // Play a metallic ping sound
                this.playBulletHitSound();
            }
            
            // Play sound when bullet hits vehicle
            playBulletHitSound() {
                try {
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    const ctx = this.audioContext;
                    
                    // Create oscillator for metallic ping
                    const oscillator = ctx.createOscillator();
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 1200; // High pitched ping
                    
                    const gainNode = ctx.createGain();
                    gainNode.gain.setValueAtTime(0.2, ctx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(ctx.destination);
                    
                    oscillator.start();
                    oscillator.stop(ctx.currentTime + 0.1);
                } catch (e) {
                    console.error("Audio error:", e);
                }
            }
            
            // Function to damage vehicle and check for destruction
            damageVehicle(amount) {
                if (!this.vehicleCanBeDamaged) return;
                
                this.vehicleHealth -= amount;
                
                // Update health display
                this.updateVehicleHealthDisplay();
                
                // Check if vehicle is destroyed
                if (this.vehicleHealth <= 0) {
                    this.vehicleHealth = 0;
                    this.createVehicleExplosion();
                }
            }
            
            // Update the health display
            updateVehicleHealthDisplay() {
                // Get the health container and fill elements
                const healthContainer = document.getElementById('vehicle-health-container');
                const healthFill = document.getElementById('vehicle-health-fill');
                
                if (healthFill) {
                    // Update health bar fill percentage
                    const healthPercent = (this.vehicleHealth / this.vehicleMaxHealth) * 100;
                    healthFill.style.width = `${healthPercent}%`;
                    
                    // Change color based on health
                    if (healthPercent > 60) {
                        healthFill.style.backgroundColor = '#00ff00'; // Green
                    } else if (healthPercent > 30) {
                        healthFill.style.backgroundColor = '#ffff00'; // Yellow
                    } else {
                        healthFill.style.backgroundColor = '#ff0000'; // Red
                    }
                }
                
                // Show/hide based on whether player is in vehicle
                if (healthContainer) {
                    healthContainer.style.display = this.isInVehicle ? 'none' : 'block';
                }
            }
            
            // Function to add UI elements to the game
            setupUI() {
                // Add vehicle health display container
                const healthContainer = document.createElement('div');
                healthContainer.id = 'vehicle-health-container';
                healthContainer.style.position = 'absolute';
                healthContainer.style.bottom = '10px';
                healthContainer.style.right = '10px';
                healthContainer.style.padding = '5px';
                healthContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                healthContainer.style.borderRadius = '5px';
                healthContainer.style.display = 'none'; // Hidden by default (when in vehicle)
                
                const healthLabel = document.createElement('div');
                healthLabel.textContent = 'Vehicle Health:';
                healthLabel.style.color = 'white';
                healthLabel.style.marginBottom = '5px';
                healthLabel.style.fontSize = '14px';
                
                const healthBar = document.createElement('div');
                healthBar.id = 'vehicle-health';
                healthBar.style.width = '150px';
                healthBar.style.height = '15px';
                healthBar.style.backgroundColor = '#333';
                healthBar.style.borderRadius = '3px';
                healthBar.style.overflow = 'hidden';
                
                const healthFill = document.createElement('div');
                healthFill.id = 'vehicle-health-fill';
                healthFill.style.width = '100%';
                healthFill.style.height = '100%';
                healthFill.style.backgroundColor = '#00ff00';
                healthFill.style.transition = 'width 0.3s, background-color 0.3s';
                
                healthBar.appendChild(healthFill);
                healthContainer.appendChild(healthLabel);
                healthContainer.appendChild(healthBar);
                document.body.appendChild(healthContainer);
            }
        }
        
        // Initialize game when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Starting GTA 2 Clone 3D...');
            const game = new Game();
        });
    </script>
</body>
</html> 