<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>GTA 2 Clone - 3D Version</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            color: #fff;
            font-family: Arial, sans-serif;
        }
        canvas { 
            display: block; 
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #fff;
            font-size: 14px;
        }
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        .control-instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: #fff;
        }
    </style>
    
    <!-- Load THREE.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="info">GTA 2 Clone - 3D Version</div>
    <div id="stats">
        Cash: $<span id="cash">0</span><br>
        Health: <span id="health">100</span>%<br>
        Wanted: <span id="wanted">0</span>/6
    </div>
    <div class="control-instructions">
        Controls: WASD or Arrow Keys to move | E to enter/exit vehicles | L to toggle lights | K to toggle day/night | SPACE for handbrake
    </div>
    
    <script>
        // Utility Functions
        function degToRad(degrees) {
            return degrees * (Math.PI / 180);
        }
        
        // Game Class
        class Game {
            constructor() {
                console.log('Game constructor called');
                
                // Initialize the game
                this.init();
            }
            
            init() {
                console.log('Initializing game...');
                
                // Constants
                this.CAMERA_HEIGHT = 40; // Reduced from 80 to 60 (25% closer)
                this.CAMERA_ANGLE = 90; // Changed from 60 to 90 (completely top-down)
                
                // Create scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87ceeb); // Sky blue
                
                // Replace day/night cycle with manual toggle
                this.isDay = true; // Start in daytime
                this.canToggleDayNight = true; // Prevent key spam
                
                // Create camera (perspective camera for 3D view)
                this.camera = new THREE.PerspectiveCamera(
                    75, window.innerWidth / window.innerHeight, 0.1, 1000
                );
                
                // Set camera position and angle for top-down view (but with perspective)
                this.camera.position.set(0, this.CAMERA_HEIGHT, 0);
                this.camera.rotation.x = degToRad(-this.CAMERA_ANGLE);
                
                // Create renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true; // Enable shadows
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows
                document.body.appendChild(this.renderer.domElement);
                
                // Handle window resize
                window.addEventListener('resize', () => this.onWindowResize());
                
                // Track collidable objects
                this.collidableObjects = [];
                
                // Collision parameters
                this.collisionRadius = 2.5; // Car collision radius
                this.bounceFactor = 0.45; // Reduced from 0.65 to make bounces less extreme
                this.sparkDuration = 500; // How long sparks last in milliseconds
                this.currentSparks = []; // Array to hold active spark effects
                this.lastCollisionTime = 0; // To prevent multiple collisions in quick succession
                this.collisionCooldown = 150; // Reduced from 200ms to allow quicker collision detection for safety
                this.lastCollisionNormal = null; // To track the normal of the last collision
                
                // Lighting state
                this.lightsOn = false;
                this.headlights = []; // Will store headlight objects
                this.taillights = []; // Will store taillight objects
                this.canToggleLights = true; // Prevent light toggle spam
                
                // Collision recovery variables
                this.inCollisionRecovery = false;
                this.collisionTargetPosition = new THREE.Vector3();
                this.collisionRepositionSpeed = 0;
                this.collisionStartPosition = new THREE.Vector3();
                this.collisionProgress = 0;
                
                // Car physics variables for improved driving model
                this.handbrakeActive = false; // Handbrake state
                this.rearTractionFactor = 1.0; // Full traction by default
                this.lateralVelocity = 0; // Side-slip velocity
                this.angularVelocity = 0; // Rotation speed
                this.driftAngle = 0; // Visual drift angle for car body
                this.wheelBase = 3.0; // Distance between front and rear wheels
                this.turnRadius = 6.0; // Turning radius at low speed
                
                // Skidmark system
                this.skidmarks = []; // Array to store skidmark meshes
                this.maxSkidmarks = 150; // Increased slightly to account for two tracks
                this.lastSkidmarkTime = 0; // To control skidmark frequency
                this.lastWheelPositions = {
                    leftRear: new THREE.Vector3(),
                    rightRear: new THREE.Vector3()
                }; // Track previous wheel positions
                this.minSegmentLength = 0.5; // Minimum length for a skidmark segment
                this.skidmarkMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000, // Pure black
                    transparent: true,
                    opacity: 0.95,
                    depthWrite: false
                });
                this.activeSkidmarks = false; // Track if skidmarks are currently being created
                
                // Sound settings for skidmarks
                this.skidSoundVolume = 0.4; // Volume for skid sound
                this.skidSoundPlaying = false; // Track if skid sound is playing
                
                // Create game objects
                this.createWorld();
                
                // Initialize player movement variables
                this.playerMaxSpeed = 80; // Increased from 30 to 50 for higher top speed
                this.playerAcceleration = 35; // Reduced from 20 to 15 for more gradual acceleration
                this.playerDeceleration = 60; // Reduced from 15 to 10 for less responsive braking
                this.playerFriction = 8; // Reduced from 10 to 5 for longer coasting/sliding
                this.playerRotationSpeed = 1.8; // Slightly reduced for more realistic turning
                this.playerVelocity = 0; // current velocity
                this.playerDirection = new THREE.Vector2(0, 0); // movement direction vector
                
                // Initialize player state
                this.isInVehicle = true; // Start in vehicle
                this.canToggleVehicle = true; // Prevent spamming E key
                this.lastVehiclePosition = new THREE.Vector3(); // Store vehicle position when exiting
                this.lastVehicleRotation = 0; // Store vehicle rotation when exiting
                
                // Camera transition parameters
                this.targetCameraHeight = this.CAMERA_HEIGHT; // Target for smooth transitions
                this.cameraTransitionSpeed = 10; // Speed of camera height transitions
                
                // Collision rotation transition parameters
                this.inRotationTransition = false;
                this.targetRotation = 0;
                this.rotationSpeed = 0;
                
                // Start animation loop
                this.lastTime = Date.now();
                this.animate();
                
                console.log('Game initialized successfully!');
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Calculate delta time for smooth movement
                const now = Date.now();
                this.deltaTime = (now - this.lastTime) / 1000; // seconds
                this.lastTime = now;
                
                // Update lighting for day/night cycle
                this.updateLighting(this.deltaTime);
                
                // Update player movement
                this.updatePlayer(this.deltaTime);
                
                // Update skidmarks
                this.updateSkidmarks(this.deltaTime);
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
                
                // Update UI stats
                document.getElementById('cash').textContent = Math.floor(Math.random() * 100);
            }
            
            createWorld() {
                // Create ground plane with improved material for better light reflection
                const groundSize = 500;
                const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333, // Dark gray for asphalt
                    roughness: 0.8,
                    metalness: 0.2
                });
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = degToRad(-90); // Rotate to be horizontal
                this.ground.position.y = 0;
                this.ground.receiveShadow = true; // Ground can receive shadows
                this.scene.add(this.ground);
                
                // Reset collidable objects array
                this.collidableObjects = [];
                
                // Create city grid
                this.createCityGrid();
                
                // Create player
                this.createPlayerVehicle();
                
                // Add lighting
                this.createLighting();
                
                // Setup keyboard controls
                this.keys = {};
                document.addEventListener('keydown', (e) => this.onKeyDown(e));
                document.addEventListener('keyup', (e) => this.onKeyUp(e));
            }
            
            createLighting() {
                // Add ambient light (general illumination)
                this.ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(this.ambientLight);
                
                // Add directional light (sun-like)
                this.sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
                this.sunLight.position.set(100, 100, 50);
                this.sunLight.castShadow = true;
                
                // Configure shadow properties for better quality
                this.sunLight.shadow.mapSize.width = 2048;
                this.sunLight.shadow.mapSize.height = 2048;
                this.sunLight.shadow.camera.near = 0.5;
                this.sunLight.shadow.camera.far = 500;
                this.sunLight.shadow.camera.left = -100;
                this.sunLight.shadow.camera.right = 100;
                this.sunLight.shadow.camera.top = 100;
                this.sunLight.shadow.camera.bottom = -100;
                
                this.scene.add(this.sunLight);
                
                // Add a subtle blue moon light for night time
                this.moonLight = new THREE.DirectionalLight(0x8888ff, 0);
                this.moonLight.position.set(-100, 100, -50);
                this.scene.add(this.moonLight);
            }
            
            updateLighting(deltaTime) {
                // Adjust lighting based on day/night state instead of time progression
                if (this.isDay) {
                    // Daytime lighting
                    this.sunLight.intensity = 0.8; // Full daylight
                    this.moonLight.intensity = 0; // No moonlight during day
                    this.ambientLight.intensity = 0.5; // Bright ambient light
                    this.scene.background = new THREE.Color(0x87ceeb); // Sky blue
                    
                    // Remove fog or make it minimal during day
                    if (!this.scene.fog) {
                        this.scene.fog = new THREE.Fog(this.scene.background, 10, 100);
                    } else {
                        this.scene.fog.color = this.scene.background;
                        this.scene.fog.far = 100; // Better visibility during day
                    }
                } else {
                    // Nighttime lighting - less dark than before
                    this.sunLight.intensity = 0; // No sunlight at night
                    this.moonLight.intensity = 0.25; // Brighter moonlight (was 0.1-0.2)
                    this.ambientLight.intensity = 0.25; // Increased ambient light (was 0.1)
                    this.scene.background = new THREE.Color(0x0a1a40); // Slightly lighter dark blue (was 0x0a1a2a)
                    
                    // Add fog at night for atmosphere
                    if (!this.scene.fog) {
                        this.scene.fog = new THREE.Fog(this.scene.background, 10, 60);
                    } else {
                        this.scene.fog.color = this.scene.background;
                        this.scene.fog.far = 60; // Reduced visibility at night but not too much
                    }
                    
                    // Auto-toggle headlights at night if they're off
                    if (!this.lightsOn) {
                        this.toggleLights();
                    }
                }
            }
            
            // Add method to toggle between day and night
            toggleDayNight() {
                this.isDay = !this.isDay;
                
                // Update lighting immediately
                this.updateLighting(0);
                
                // Update info text
                document.getElementById('info').textContent = this.isDay ? 
                    "GTA 2 Clone - Daytime (Press K to toggle)" : 
                    "GTA 2 Clone - Nighttime (Press K to toggle)";
            }
            
            onKeyDown(event) {
                this.keys[event.key.toLowerCase()] = true;
                
                // Handle vehicle entry/exit with E key
                if (event.key.toLowerCase() === 'e' && this.canToggleVehicle) {
                    this.toggleVehicle();
                    // Prevent key spam by adding a cooldown
                    this.canToggleVehicle = false;
                    setTimeout(() => {
                        this.canToggleVehicle = true;
                    }, 500); // 500ms cooldown
                }
                
                // Handle light toggle with L key
                if (event.key.toLowerCase() === 'l' && this.canToggleLights) {
                    this.toggleLights();
                    // Prevent light toggle spam
                    this.canToggleLights = false;
                    setTimeout(() => {
                        this.canToggleLights = true;
                    }, 500); // 500ms cooldown
                }
                
                // Handle day/night toggle with K key
                if (event.key.toLowerCase() === 'k' && this.canToggleDayNight) {
                    this.toggleDayNight();
                    // Prevent toggle spam
                    this.canToggleDayNight = false;
                    setTimeout(() => {
                        this.canToggleDayNight = true;
                    }, 500); // 500ms cooldown
                }
                
                // Handle handbrake with SPACE key
                if (event.key === ' ' && this.isInVehicle && !this.handbrakeActive) {
                    this.handbrakeActive = true;
                    
                    // Reset skidmark tracking when handbrake is activated
                    this.lastWheelPositions.leftRear.set(0, 0, 0);
                    this.lastWheelPositions.rightRear.set(0, 0, 0);
                    this.activeSkidmarks = true;
                    
                    // Reduce rear wheel traction when handbrake is active
                    this.rearTractionFactor = 0.02; // Almost no rear traction
                    
                    // Front traction remains high - only rear wheels lose grip
                    this.frontTractionFactor = 0.98; // High front traction maintained
                    
                    // Add some lateral velocity for better drift initiation when turning
                    if (Math.abs(this.playerVelocity) > 5) {
                        const isTurningLeft = this.keys['a'] || this.keys['arrowleft'];
                        const isTurningRight = this.keys['d'] || this.keys['arrowright'];
                        
                        if (isTurningLeft || isTurningRight) {
                            // Add lateral velocity kick in the OPPOSITE direction to the turn
                            // This is crucial - for a left turn, the car should slide right
                            const turnDirection = isTurningLeft ? 1 : -1;
                            
                            // Apply strong outward lateral force (opposite to turn direction)
                            this.lateralVelocity -= turnDirection * Math.abs(this.playerVelocity) * 0.4;
                            
                            // Add a strong angular velocity kick in the TURNING direction
                            // This makes the car rotate/spin in the direction of the turn
                            this.angularVelocity += turnDirection * Math.abs(this.playerVelocity) * 0.03;
                            
                            // Reduce forward velocity to simulate braking effect
                            this.playerVelocity *= 0.85;
                        }
                    }
                    
                    // Play handbrake sound effect
                    this.playHandbrakeSound();
                    
                    // Update info text
                    document.getElementById('info').textContent = "HANDBRAKE ENGAGED";
                    setTimeout(() => {
                        if (this.handbrakeActive) {
                            document.getElementById('info').textContent = "GTA 2 Clone - Drifting";
                        }
                    }, 1000);
                }
            }
            
            onKeyUp(event) {
                this.keys[event.key.toLowerCase()] = false;
                
                // Handle handbrake release with SPACE key
                if (event.key === ' ' && this.isInVehicle) {
                    this.handbrakeActive = false;
                    this.activeSkidmarks = false;
                    
                    // Reset skidmark tracking when handbrake is released
                    this.lastWheelPositions.leftRear.set(0, 0, 0);
                    this.lastWheelPositions.rightRear.set(0, 0, 0);
                    
                    // Reset traction factors to defaults
                    this.frontTractionFactor = 0.95;
                    
                    // Reset info text
                    document.getElementById('info').textContent = "GTA 2 Clone - 3D Version";
                }
            }
            
            playHandbrakeSound() {
                // Only start a new sound if one isn't already playing
                if (!this.skidSoundPlaying) {
                    if (this.handbrakeSound) {
                        this.handbrakeSound.stop(); // Stop any previous instance
                    }
                    
                    // Create an improved skid sound
                    this.handbrakeSound = new THREE.Audio(this.audioListener);
                    this.audioLoader.load('assets/audio/tires-skid2.mp3', (buffer) => {
                        this.handbrakeSound.setBuffer(buffer);
                        this.handbrakeSound.setLoop(true);
                        this.handbrakeSound.setVolume(this.skidSoundVolume);
                        this.handbrakeSound.play();
                        this.skidSoundPlaying = true;
                    });
                    
                    // Schedule the sound to stop after releasing handbrake with a slight delay
                    setTimeout(() => {
                        if (this.handbrakeSound && !this.handbrakeActive) {
                            // Fade out the sound to avoid abrupt stop
                            const fadeOutInterval = setInterval(() => {
                                if (this.handbrakeSound.getVolume() > 0.05) {
                                    this.handbrakeSound.setVolume(this.handbrakeSound.getVolume() - 0.05);
                                } else {
                                    this.handbrakeSound.stop();
                                    this.skidSoundPlaying = false;
                                    clearInterval(fadeOutInterval);
                                }
                            }, 50);
                        }
                    }, 300);
                }
            }
            
            createNoiseBuffer(audioContext) {
                // Create a buffer of white noise for realistic tire sounds
                const bufferSize = audioContext.sampleRate * 0.5; // 0.5 second buffer
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                // Fill the buffer with noise
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                return buffer;
            }
            
            updatePlayer(deltaTime) {
                if (!this.player) return;
                
                // Different controls based on whether player is in vehicle or on foot
                if (this.isInVehicle) {
                    this.updateVehicle(deltaTime);
                } else {
                    this.updatePedestrian(deltaTime);
                }
                
                // Update camera position to follow player (whether in vehicle or pedestrian)
                const target = this.isInVehicle ? this.player : this.pedestrian;
                
                // Smoothly interpolate camera height
                const heightDifference = this.targetCameraHeight - this.camera.position.y;
                if (Math.abs(heightDifference) > 0.1) {
                    this.camera.position.y += heightDifference * Math.min(1, this.cameraTransitionSpeed * deltaTime);
                } else {
                    this.camera.position.y = this.targetCameraHeight;
                }
                
                this.camera.position.x = target.position.x;
                this.camera.position.z = target.position.z;
                
                // Always look straight down at the player
                this.camera.lookAt(
                    target.position.x,
                    target.position.y,
                    target.position.z
                );
                
                // Keep camera rotation values fixed
                this.camera.rotation.z = 0;
                this.camera.rotation.x = degToRad(-this.CAMERA_ANGLE);
            }
            
            updateVehicle(deltaTime) {
                // Forward/backward input
                let moveInput = 0;
                if (this.keys['w'] || this.keys['arrowup']) {
                    moveInput = 1;
                } else if (this.keys['s'] || this.keys['arrowdown']) {
                    moveInput = -1;
                }
                
                // Left/right rotation
                let rotateY = 0;
                if (this.keys['a'] || this.keys['arrowleft']) {
                    rotateY = 1;
                } else if (this.keys['d'] || this.keys['arrowright']) {
                    rotateY = -1;
                }
                
                // Check if car is completely stopped
                const isCarStopped = Math.abs(this.playerVelocity) < 0.5 && Math.abs(this.lateralVelocity) < 0.5;
                
                // When car is stopped with no input, reset all momentum to prevent sliding
                if (isCarStopped && moveInput === 0 && rotateY === 0 && !this.handbrakeActive) {
                    this.playerVelocity = 0;
                    this.lateralVelocity = 0;
                    this.angularVelocity = 0;
                }
                
                // Apply rotation
                if (rotateY !== 0) {
                    // Scale rotation speed based on velocity for more realistic turning
                    // Slower rotation at higher speeds
                    const speedFactor = Math.max(0.2, 1.0 - (Math.abs(this.playerVelocity) / this.playerMaxSpeed));
                    
                    // Base rotation adjustment
                    let rotationAdjustment = rotateY * this.playerRotationSpeed * speedFactor * deltaTime;
                    
                    // Apply rear-wheel drive physics and handbrake effects
                    if (this.handbrakeActive && Math.abs(this.playerVelocity) > 5) {
                        // When handbrake is active and we're moving fast enough:
                        // 1. Increase rotation rate (makes car rotate faster)
                        rotationAdjustment *= 2.0;
                        
                        // 2. Apply additional angular momentum based on current speed
                        // This creates the characteristic "swing" of a handbrake turn
                        const handbrakeRotationBoost = rotateY * Math.abs(this.playerVelocity) * 0.03 * deltaTime;
                        this.angularVelocity += handbrakeRotationBoost;
                        
                        // Continue playing tire squeal sound during drift
                        if (Math.random() < 0.1) {
                            this.playHandbrakeSound();
                        }
                    }
                    
                    // Apply rotation, including any angular velocity from drifting
                    this.player.rotation.y += rotationAdjustment + (this.angularVelocity * deltaTime);
                    
                    // Add some lateral velocity when turning (creates realistic side movement)
                    if (Math.abs(this.playerVelocity) > 10) {
                        // More lateral force at higher speeds
                        const lateralForce = rotateY * 0.5 * Math.abs(this.playerVelocity) / 20;
                        
                        // More lateral force when handbrake is engaged
                        this.lateralVelocity += lateralForce * deltaTime * (this.handbrakeActive ? 3.0 : 1.0);
                    }
                } else {
                    // Still apply any existing angular velocity
                    this.player.rotation.y += this.angularVelocity * deltaTime;
                }
                
                // Apply acceleration/deceleration based on input
                if (moveInput !== 0) {
                    // Accelerate in the input direction
                    if ((moveInput > 0 && this.playerVelocity < 0) || 
                        (moveInput < 0 && this.playerVelocity > 0)) {
                        // Braking (moving in opposite direction of current velocity)
                        this.playerVelocity += moveInput * this.playerDeceleration * deltaTime;
                        
                        // Activate brake lights when braking
                        this.updateBrakeLights(true);
                    } else {
                        // Accelerating - apply rear wheel drive physics
                        // Wheelspin effect when handbrake is active
                        const accelerationFactor = this.handbrakeActive ? 0.3 : 1.0;
                        
                        // Acceleration is reduced at higher speeds (torque curve simulation)
                        const speedScale = 1.0 - (Math.abs(this.playerVelocity) / this.playerMaxSpeed) * 0.7;
                        
                        this.playerVelocity += moveInput * this.playerAcceleration * accelerationFactor * speedScale * deltaTime;
                        
                        // Deactivate brake lights when accelerating
                        this.updateBrakeLights(false);
                    }
                } else if (this.playerVelocity !== 0) {
                    // Apply friction when no input
                    const frictionForce = Math.min(Math.abs(this.playerVelocity), this.playerFriction * deltaTime);
                    this.playerVelocity -= Math.sign(this.playerVelocity) * frictionForce;
                    
                    // Prevent tiny floating point oscillations near zero
                    if (Math.abs(this.playerVelocity) < 0.01) {
                        this.playerVelocity = 0;
                    }
                    
                    // Medium brake lights when coasting (engine braking)
                    this.updateBrakeLights(false);
                } else {
                    // Vehicle is completely stopped
                    this.updateBrakeLights(false);
                }
                
                // Clamp velocity to max speed
                this.playerVelocity = Math.max(-this.playerMaxSpeed, Math.min(this.playerMaxSpeed, this.playerVelocity));
                
                // Only apply movement if we have any velocity (forward, lateral or angular)
                if (Math.abs(this.playerVelocity) > 0.01 || Math.abs(this.lateralVelocity) > 0.01 || Math.abs(this.angularVelocity) > 0.01) {
                    // Calculate forward direction based on player's rotation
                    const angle = this.player.rotation.y;
                    const x = Math.sin(angle) * this.playerVelocity * deltaTime;
                    const z = Math.cos(angle) * this.playerVelocity * deltaTime;
                    
                    // Add lateral movement (side slip) - will be greater with handbrake
                    // Calculate lateral direction (perpendicular to forward)
                    const lateralX = Math.sin(angle + Math.PI/2) * this.lateralVelocity * deltaTime;
                    const lateralZ = Math.cos(angle + Math.PI/2) * this.lateralVelocity * deltaTime;
                    
                    // Store previous position for collision detection
                    const previousPosition = new THREE.Vector3().copy(this.player.position);
                    
                    // Only apply direct movement if not in collision recovery
                    if (!this.inCollisionRecovery) {
                        // Apply both forward and lateral movement
                        this.player.position.x -= (x + lateralX); 
                        this.player.position.z -= (z + lateralZ);
                    }
                    
                    // Create skidmarks if handbrake is active and car is moving
                    if (this.handbrakeActive && Math.abs(this.playerVelocity) > 5) {
                        this.createSkidmarks();
                    }
                    
                    // Handle gradual collision recovery
                    if (this.inCollisionRecovery) {
                        // Increment progress based on speed and time
                        this.collisionProgress += this.collisionRepositionSpeed * deltaTime;
                        
                        if (this.collisionProgress >= 1.0) {
                            // We've completed the recovery
                            this.player.position.copy(this.collisionTargetPosition);
                            this.inCollisionRecovery = false;
                        } else {
                            // Interpolate between start and target positions
                            this.player.position.lerpVectors(
                                this.collisionStartPosition,
                                this.collisionTargetPosition,
                                this.collisionProgress
                            );
                        }
                    }
                    
                    // Check for collisions with buildings and objects
                    const collisionInfo = this.checkVehicleCollisions();
                    
                    if (collisionInfo.collision) {
                        // Handle collision response - realistic bounce off
                        this.handleCollision(collisionInfo, previousPosition);
                        
                        // Create spark effects at collision point
                        this.createSparkEffect(collisionInfo.point);
                    }
                }
                
                // Apply drift physics
                this.applyDriftPhysics(deltaTime);
                
                // Apply smooth rotation transition after collision if needed
                if (this.inRotationTransition) {
                    // Move towards target rotation
                    const currentAngle = this.player.rotation.y;
                    const angleDifference = this.targetRotation - currentAngle;
                    
                    // Normalize angle difference to [-π, π]
                    let normalizedDifference = angleDifference;
                    while (normalizedDifference > Math.PI) normalizedDifference -= 2 * Math.PI;
                    while (normalizedDifference < -Math.PI) normalizedDifference += 2 * Math.PI;
                    
                    if (Math.abs(normalizedDifference) < 0.05) {
                        // Close enough, end transition
                        this.player.rotation.y = this.targetRotation;
                        this.inRotationTransition = false;
                    } else {
                        // Use the speed-based rotation value and apply it with time adjustment
                        // Higher rotationSpeed = faster initial rotation
                        const rotationStep = normalizedDifference * Math.min(1, this.rotationSpeed * deltaTime);
                        this.player.rotation.y += rotationStep;
                        
                        // Gradually decelerate the rotation speed (simulates momentum dissipation)
                        this.rotationSpeed *= (1 - deltaTime * 1.5);
                        
                        // Gradually reduce speed during sharp turns (simulates friction)
                        if (Math.abs(normalizedDifference) > 0.5 && this.playerVelocity > 10) {
                            this.playerVelocity *= (1 - (deltaTime * 0.5));
                        }
                    }
                }

                // Update active spark effects
                this.updateSparkEffects(deltaTime);
            }
            
            checkVehicleCollisions() {
                // Only check if we're not in collision cooldown
                const now = Date.now();
                if (now - this.lastCollisionTime < this.collisionCooldown) {
                    // If we're still in cooldown but not for a wall with the same normal
                    // Check if we're very close to a different wall to prevent getting stuck between walls
                    if (this.lastCollisionNormal) {
                        // Check for critical collisions even during cooldown
                        const carPosition = new THREE.Vector2(this.player.position.x, this.player.position.z);
                        
                        // Check each collidable object
                        for (const obj of this.collidableObjects) {
                            if (obj.type === 'building') {
                                // Calculate if car is VERY close to the building (half normal radius)
                                const halfWidth = obj.width / 2;
                                const halfDepth = obj.depth / 2;
                                
                                // Building boundaries
                                const minX = obj.position.x - halfWidth;
                                const maxX = obj.position.x + halfWidth;
                                const minZ = obj.position.z - halfDepth;
                                const maxZ = obj.position.z + halfDepth;
                                
                                // Car collision circle - is the car colliding with the rectangle?
                                const closestX = Math.max(minX, Math.min(carPosition.x, maxX));
                                const closestZ = Math.max(minZ, Math.min(carPosition.y, maxZ));
                                
                                // Calculate distance from closest point
                                const distanceX = carPosition.x - closestX;
                                const distanceZ = carPosition.y - closestZ;
                                const distanceSquared = distanceX * distanceX + distanceZ * distanceZ;
                                
                                // Check if we're very close (half normal distance)
                                if (distanceSquared < (this.collisionRadius * this.collisionRadius * 0.5)) {
                                    // Calculate collision normal
                                    const collisionNormal = new THREE.Vector2(distanceX, distanceZ).normalize();
                                    
                                    // If this is a significantly different wall (angle > 45 degrees)
                                    // than the one we just hit, handle the collision even in cooldown
                                    const dotProduct = collisionNormal.dot(this.lastCollisionNormal);
                                    if (dotProduct < 0.7) { // cos(45°) ≈ 0.7
                                        this.lastCollisionTime = now;
                                        this.lastCollisionNormal = collisionNormal.clone();
                                        
                                        // Calculate exact collision point
                                        const collisionPoint = new THREE.Vector3(
                                            closestX + collisionNormal.x * this.collisionRadius * 0.5,
                                            obj.height * 0.1, // Slightly above ground level
                                            closestZ + collisionNormal.y * this.collisionRadius * 0.5
                                        );
                                        
                                        return {
                                            collision: true,
                                            normal: collisionNormal,
                                            point: collisionPoint,
                                            object: obj,
                                            critical: true // Flag as a critical collision during cooldown
                                        };
                                    }
                                }
                            }
                        }
                    }
                    
                    return { collision: false };
                }
                
                // Regular collision detection
                const carPosition = new THREE.Vector2(this.player.position.x, this.player.position.z);
                
                // Check each collidable object
                for (const obj of this.collidableObjects) {
                    if (obj.type === 'building') {
                        // Calculate if car is within the building's footprint with some buffer
                        const halfWidth = obj.width / 2;
                        const halfDepth = obj.depth / 2;
                        
                        // Building boundaries
                        const minX = obj.position.x - halfWidth;
                        const maxX = obj.position.x + halfWidth;
                        const minZ = obj.position.z - halfDepth;
                        const maxZ = obj.position.z + halfDepth;
                        
                        // Car collision circle - is the car colliding with the rectangle?
                        // Use a simplified approach: check if the car's circle intersects with the building's rectangle
                        const closestX = Math.max(minX, Math.min(carPosition.x, maxX));
                        const closestZ = Math.max(minZ, Math.min(carPosition.y, maxZ));
                        
                        // Calculate distance from closest point
                        const distanceX = carPosition.x - closestX;
                        const distanceZ = carPosition.y - closestZ;
                        const distanceSquared = distanceX * distanceX + distanceZ * distanceZ;
                        
                        if (distanceSquared < (this.collisionRadius * this.collisionRadius)) {
                            // We have a collision!
                            this.lastCollisionTime = now;
                            
                            // Calculate collision normal (direction to push the car away)
                            const collisionNormal = new THREE.Vector2(distanceX, distanceZ).normalize();
                            this.lastCollisionNormal = collisionNormal.clone();
                            
                            // Calculate exact collision point
                            const collisionPoint = new THREE.Vector3(
                                closestX + collisionNormal.x * this.collisionRadius * 0.5,
                                obj.height * 0.1, // Slightly above ground level
                                closestZ + collisionNormal.y * this.collisionRadius * 0.5
                            );
                            
                            return {
                                collision: true,
                                normal: collisionNormal,
                                point: collisionPoint,
                                object: obj
                            };
                        }
                    }
                }
                
                return { collision: false };
            }
            
            handleCollision(collisionInfo, previousPosition) {
                // Get the car's original speed
                const originalSpeed = Math.abs(this.playerVelocity);
                
                // Create a truly linear relationship between speed and safety margin
                // At speeds below 1.0, there's almost no safety margin (bare minimum to prevent sticking)
                const safetyMargin = originalSpeed < 1.0 ? 0.01 : Math.min(0.12, 0.01 + originalSpeed * 0.004);
                
                // Calculate push vector based on collision normal with linear scaling
                // For extremely low speeds (< 1.0), provide just enough to prevent sticking
                const pushDistance = originalSpeed < 1.0 ? 0.02 : this.collisionRadius * (0.02 + originalSpeed * 0.003);
                const pushbackVector = new THREE.Vector3(
                    collisionInfo.normal.x * pushDistance,
                    0,
                    collisionInfo.normal.y * pushDistance
                );
                
                // Calculate target position (outside the wall)
                const targetPosition = new THREE.Vector3().copy(previousPosition).add(pushbackVector);
                
                // Setup collision recovery
                this.collisionStartPosition.copy(this.player.position);
                this.collisionTargetPosition.copy(targetPosition);
                
                // Make repositioning truly linear with speed
                // At near-zero speeds, almost no movement
                this.collisionRepositionSpeed = originalSpeed < 1.0 ? 1.0 : 1.0 + originalSpeed / 5;
                
                // Reset progress
                this.collisionProgress = 0;
                
                // Enable collision recovery mode
                this.inCollisionRecovery = true;
                
                // Continue with the rest of collision handling
                // Get the car's velocity vector
                const angle = this.player.rotation.y;
                const velocityVector = new THREE.Vector2(
                    -Math.sin(angle) * this.playerVelocity,
                    -Math.cos(angle) * this.playerVelocity
                );
                
                // Calculate how direct the hit was (1.0 = head-on, 0.0 = grazing)
                const dot = velocityVector.x * collisionInfo.normal.x + velocityVector.y * collisionInfo.normal.y;
                const normalizedDot = Math.abs(dot) / (velocityVector.length() * collisionInfo.normal.length());
                
                // --- REVISED PHYSICS MODEL FOR LINEAR SPEED-DEPENDENT COLLISIONS ---
                
                // For extremely low speeds, barely any effect
                if (originalSpeed < 1.5) {
                    this.playerVelocity = 0; // Stop completely
                    this.playCollisionSound(0.1); // Very quiet sound
                    return; // Skip the rest of the collision handling
                }
                
                // Low speeds (1.5-10) get very gentle, proportional bounces
                if (originalSpeed < 10) {
                    // Calculate reflection direction (normalized)
                    const reflectionDir = new THREE.Vector2(
                        velocityVector.x - 2 * dot * collisionInfo.normal.x,
                        velocityVector.y - 2 * dot * collisionInfo.normal.y
                    ).normalize();
                    
                    // Linear energy loss - more speed = more loss, perfectly linear
                    const energyLoss = 0.5 + (originalSpeed / 20); // 0.5 at low speeds, up to 1.0 at 10 speed
                    
                    // Calculate new speed - linear relationship to original speed
                    const newSpeed = originalSpeed * Math.max(0, 1 - energyLoss);
                    
                    // Set the car's new velocity - gentle, proportional bounce
                    this.playerVelocity = newSpeed;
                    
                    // No rotation change for speeds under 5
                    if (originalSpeed < 5) {
                        // Zero rotation change
                        this.playCollisionSound(originalSpeed * 0.1);
                        return;
                    }
                    
                    // Minimal rotation for speeds 5-10, linearly increasing
                    const rotationFactor = (originalSpeed - 5) / 5; // 0 at speed 5, 1.0 at speed 10
                    const maxAngleChange = rotationFactor * 0.1; // Up to ~6 degrees at speed 10
                    
                    // Apply tiny rotation based on which side was hit
                    const sideHit = dot > 0 ? 1 : -1;
                    this.player.rotation.y += maxAngleChange * sideHit;
                    
                    // Play proportional collision sound
                    this.playCollisionSound(originalSpeed * 0.1);
                    return;
                }
                
                // For speeds 10+, use existing logic but with more linear response
                // Calculate reflection direction (normalized)
                const reflectionDir = new THREE.Vector2(
                    velocityVector.x - 2 * dot * collisionInfo.normal.x,
                    velocityVector.y - 2 * dot * collisionInfo.normal.y
                ).normalize();
                
                // MORE REALISTIC PHYSICS WITH LINEAR ENERGY LOSS:
                
                // Linear energy loss based on speed (no quadratic functions)
                const speedBasedEnergyLoss = Math.min(0.95, 0.35 + (originalSpeed / 100));
                
                // Direct hits lose more energy - linear relationship
                const angleBasedEnergyLoss = normalizedDot * 0.85;
                
                // Combine energy losses - linear relationship to speed
                const totalEnergyLoss = Math.min(0.95, speedBasedEnergyLoss + angleBasedEnergyLoss);
                
                // Calculate new speed with more energy loss
                const wallDampingFactor = 0.7; // Walls absorb 30% of energy on all collisions
                const energyFactor = (1 - totalEnergyLoss) * wallDampingFactor;
                const newSpeed = originalSpeed * Math.max(0.01, energyFactor);
                
                // Set the car's new velocity with reduced bounce effect
                this.playerVelocity = newSpeed;
                
                // IMPROVED ROTATION HANDLING:
                if (originalSpeed > 10) {
                    // Calculate new angle from reflection vector
                    const newAngle = Math.atan2(-reflectionDir.x, -reflectionDir.y);
                    
                    // Calculate offset angle for glancing blows - linear with speed
                    const glancingFactor = (1 - normalizedDot); // Higher for glancing blows
                    
                    // Linear speed factor - no quadratic scaling
                    const speedFactor = originalSpeed / 40; // Linear growth relative to speed
                    
                    // Calculate rotational impulse with linear scaling
                    const rotationalImpulse = glancingFactor * speedFactor * Math.PI * 0.4;
                    
                    // Apply rotational impulse in the appropriate direction
                    // (based on which side of the car was hit)
                    const sideHit = dot > 0 ? 1 : -1;
                    const rotationOffset = rotationalImpulse * sideHit;
                    
                    // Set up smooth transition with speed-dependent rotation
                    this.targetRotation = newAngle + rotationOffset;
                    this.inRotationTransition = true;
                    
                    // Linear rotation transition speed based on car speed
                    this.rotationSpeed = 3 + originalSpeed / 10;
                    
                    // Linear slowdown during rotation
                    const angleDifference = Math.abs(this.targetRotation - this.player.rotation.y);
                    if (angleDifference > 0.8 && this.playerVelocity > 10) {
                        // Linear speed reduction
                        this.playerVelocity *= (1 - (speedFactor * 0.4));
                    }
                }
                
                // Play collision sound with volume based on impact force
                this.playCollisionSound(originalSpeed * normalizedDot * 0.05);
                
                // Add damage based on impact force
                if (originalSpeed > 20 && normalizedDot > 0.5) {
                    const damage = Math.floor((originalSpeed / 10) * normalizedDot);
                    document.getElementById('health').textContent = 
                        Math.max(0, parseInt(document.getElementById('health').textContent) - damage);
                }
                
                // Create spark effect at low speeds too
                if (originalSpeed > 3) {
                    this.createSparkEffect(collisionInfo.point);
                }
            }
            
            playCollisionSound(impactSpeed) {
                // Create a simple collision sound with Web Audio API
                // Volume based on impact speed
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // Impact sound properties
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(100 + impactSpeed * 10, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(20, audioContext.currentTime + 0.1);
                    
                    // Volume based on impact
                    const volume = Math.min(0.3, impactSpeed / this.playerMaxSpeed);
                    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                } catch (e) {
                    console.log("Audio not supported or not allowed:", e);
                }
            }
            
            createSparkEffect(position) {
                // Create a particle group for sparks
                // Increase spark count significantly based on speed
                const sparkCount = 25 + Math.floor(Math.abs(this.playerVelocity) / 3);
                const sparkGroup = new THREE.Group();
                // Position the group at the exact collision point, not the car center
                sparkGroup.position.copy(position);
                this.scene.add(sparkGroup);
                
                // Create individual spark particles
                for (let i = 0; i < sparkCount; i++) {
                    // Random spark direction in semicircle facing away from collision
                    // Make sparks spread in a wider arc
                    const angle = Math.random() * Math.PI * 1.5 - Math.PI * 0.25;
                    // Increase speed range for more dynamic effect
                    const speed = 8 + Math.random() * 15; // Higher speed values
                    
                    // Create larger particles
                    const sparkSize = 0.2 + Math.random() * 0.3; // Increased from 0.1 fixed size
                    const sparkGeometry = new THREE.BoxGeometry(sparkSize, sparkSize, sparkSize);
                    
                    // Brighter, more vibrant materials with glow effect
                    const sparkColors = [0xffaa00, 0xffdd00, 0xff5500]; // Orange, yellow, bright orange
                    const sparkMaterial = new THREE.MeshBasicMaterial({
                        color: sparkColors[Math.floor(Math.random() * sparkColors.length)],
                        emissive: 0xffff00,
                        emissiveIntensity: 2, // Increased intensity
                        transparent: true, 
                        opacity: 0.9
                    });
                    
                    const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                    spark.castShadow = false;
                    spark.receiveShadow = false;
                    
                    // Add to group
                    sparkGroup.add(spark);
                    
                    // Random direction and velocity - more upward movement and spread
                    spark.userData = {
                        velocity: new THREE.Vector3(
                            Math.cos(angle) * speed,
                            6 + Math.random() * 12, // More upward velocity
                            Math.sin(angle) * speed
                        ),
                        created: Date.now(),
                        // Add rotation for more dynamic effect
                        rotationSpeed: new THREE.Vector3(
                            Math.random() * 20 - 10,
                            Math.random() * 20 - 10,
                            Math.random() * 20 - 10
                        )
                    };
                }
                
                // Track this spark effect
                this.currentSparks.push({
                    group: sparkGroup,
                    created: Date.now()
                });
                
                // Make low-speed collisions also create sparks, just fewer
                if (Math.abs(this.playerVelocity) < 5) {
                    this.sparkDuration = 300; // Shorter duration for low-speed impacts
                } else {
                    this.sparkDuration = 800; // Longer duration for high-speed impacts
                }
            }
            
            updateSparkEffects(deltaTime) {
                const now = Date.now();
                const gravity = 9.8; // Gravity for spark physics
                
                // Update each spark group
                for (let i = this.currentSparks.length - 1; i >= 0; i--) {
                    const sparkEffect = this.currentSparks[i];
                    const elapsed = now - sparkEffect.created;
                    
                    // Handle smoke particles differently than sparks
                    if (sparkEffect.isSmoke) {
                        // Smoke has longer lifetime
                        if (elapsed > 1500) {
                            this.scene.remove(sparkEffect.group);
                            this.currentSparks.splice(i, 1);
                            continue;
                        }
                        
                        // Update each smoke particle
                        sparkEffect.group.children.forEach(smoke => {
                            // Apply gravity (less than for sparks - smoke rises)
                            smoke.userData.velocity.y -= gravity * 0.3 * deltaTime;
                            
                            // Move smoke based on velocity
                            smoke.position.x += smoke.userData.velocity.x * deltaTime;
                            smoke.position.y += smoke.userData.velocity.y * deltaTime;
                            smoke.position.z += smoke.userData.velocity.z * deltaTime;
                            
                            // Slow down horizontal velocity over time
                            smoke.userData.velocity.x *= 0.98;
                            smoke.userData.velocity.z *= 0.98;
                            
                            // Rotate smoke for dynamic effect
                            smoke.rotation.z += smoke.userData.rotation;
                            
                            // Expand smoke over time
                            const lifeFraction = elapsed / smoke.userData.fadeTime;
                            const scale = 1.0 + lifeFraction * 3.0; // Gets 4x larger
                            smoke.scale.set(scale, scale, 1);
                            
                            // Fade out smoke as it ages
                            smoke.material.opacity = Math.max(0, 0.4 - lifeFraction * 0.4);
                        });
                        
                        continue;
                    }
                    
                    // Handle regular spark particles - original code
                    // Remove old spark effects
                    if (elapsed > this.sparkDuration) {
                        this.scene.remove(sparkEffect.group);
                        this.currentSparks.splice(i, 1);
                        continue;
                    }
                    
                    // Update each individual spark particle
                    sparkEffect.group.children.forEach(spark => {
                        // Apply gravity to velocity with more gradual effect
                        spark.userData.velocity.y -= gravity * 1.5 * deltaTime;
                        
                        // Move spark based on velocity
                        spark.position.x += spark.userData.velocity.x * deltaTime;
                        spark.position.y += spark.userData.velocity.y * deltaTime;
                        spark.position.z += spark.userData.velocity.z * deltaTime;
                        
                        // Add rotation to sparks for more dynamic effect
                        spark.rotation.x += spark.userData.rotationSpeed.x * deltaTime;
                        spark.rotation.y += spark.userData.rotationSpeed.y * deltaTime;
                        spark.rotation.z += spark.userData.rotationSpeed.z * deltaTime;
                        
                        // If spark hits ground, bounce with reduced energy
                        if (spark.position.y < 0.1) {
                            spark.position.y = 0.1;
                            spark.userData.velocity.y = -spark.userData.velocity.y * 0.4; // More bounce
                            
                            // Reduce horizontal velocity (friction with ground)
                            spark.userData.velocity.x *= 0.8;
                            spark.userData.velocity.z *= 0.8;
                        }
                        
                        // Fade out spark as it ages - use a different curve that keeps sparks visible longer
                        const sparkAge = elapsed;
                        // Keep full opacity for first half of life, then fade
                        const lifeFraction = sparkAge / this.sparkDuration;
                        const opacity = lifeFraction < 0.6 ? 1.0 : 1.0 - ((lifeFraction - 0.6) / 0.4);
                        spark.material.opacity = opacity;
                        
                        // Scale sparks - start larger, then get smaller
                        const scale = 1.0 - (lifeFraction * 0.7);
                        spark.scale.set(scale, scale, scale);
                        
                        // Colorful effect - transition from yellow to red as sparks age
                        if (lifeFraction > 0.3) {
                            // Transition color from original to red
                            const r = 1.0;
                            const g = Math.max(0, 0.7 - lifeFraction);
                            const b = 0;
                            spark.material.color.setRGB(r, g, b);
                        }
                    });
                }
            }
            
            updatePedestrian(deltaTime) {
                // Pedestrian movement constants
                const pedestrianSpeed = 20; // Walking speed
                
                // Get movement input
                let moveX = 0;
                let moveZ = 0;
                
                if (this.keys['w'] || this.keys['arrowup']) moveZ = -1;
                if (this.keys['s'] || this.keys['arrowdown']) moveZ = 1;
                if (this.keys['a'] || this.keys['arrowleft']) moveX = -1;
                if (this.keys['d'] || this.keys['arrowright']) moveX = 1;
                
                // Normalize diagonal movement
                if (moveX !== 0 && moveZ !== 0) {
                    const length = Math.sqrt(moveX * moveX + moveZ * moveZ);
                    moveX /= length;
                    moveZ /= length;
                }
                
                // Store previous position for collision detection
                const previousPosition = new THREE.Vector3().copy(this.pedestrian.position);
                
                // Move the pedestrian
                if (moveX !== 0 || moveZ !== 0) {
                    // Update position
                    this.pedestrian.position.x += moveX * pedestrianSpeed * deltaTime;
                    this.pedestrian.position.z += moveZ * pedestrianSpeed * deltaTime;
                    
                    // Rotate pedestrian to face movement direction
                    const angle = Math.atan2(moveX, moveZ);
                    this.pedestrian.rotation.y = angle;
                    
                    // Check for collisions after movement
                    const pedestrianCollisionInfo = this.checkPedestrianCollisions();
                    if (pedestrianCollisionInfo.collision) {
                        // Simple collision response - move back to previous position
                        this.pedestrian.position.copy(previousPosition);
                    }
                }
                
                // Check if pedestrian is close enough to vehicle to enter it
                if (this.player && this.pedestrian) {
                    const distance = this.pedestrian.position.distanceTo(this.player.position);
                    if (distance < 5) { // Within 5 units of vehicle
                        document.getElementById('info').textContent = "GTA 2 Clone - Press E to enter vehicle";
                    } else {
                        document.getElementById('info').textContent = "GTA 2 Clone - 3D Version";
                    }
                }
            }
            
            checkPedestrianCollisions() {
                // Simple collision detection between pedestrian and buildings
                const pedestrianPosition = new THREE.Vector2(this.pedestrian.position.x, this.pedestrian.position.z);
                const pedestrianRadius = 0.5; // Smaller collision radius for pedestrian
                
                // Check each collidable object
                for (const obj of this.collidableObjects) {
                    if (obj.type === 'building') {
                        // Calculate if pedestrian is within the building's footprint
                        const halfWidth = obj.width / 2;
                        const halfDepth = obj.depth / 2;
                        
                        // Building boundaries
                        const minX = obj.position.x - halfWidth;
                        const maxX = obj.position.x + halfWidth;
                        const minZ = obj.position.z - halfDepth;
                        const maxZ = obj.position.z + halfDepth;
                        
                        // Pedestrian collision circle - is it colliding with the rectangle?
                        const closestX = Math.max(minX, Math.min(pedestrianPosition.x, maxX));
                        const closestZ = Math.max(minZ, Math.min(pedestrianPosition.y, maxZ));
                        
                        // Calculate distance from closest point
                        const distanceX = pedestrianPosition.x - closestX;
                        const distanceZ = pedestrianPosition.y - closestZ;
                        const distanceSquared = distanceX * distanceX + distanceZ * distanceZ;
                        
                        if (distanceSquared < (pedestrianRadius * pedestrianRadius)) {
                            // We have a collision!
                            return { collision: true };
                        }
                    }
                }
                
                return { collision: false };
            }
            
            createCityGrid() {
                // Create a simple city grid
                const blockSize = 50;
                const streetWidth = 16;
                const gridSize = 3; // 3x3 grid of city blocks
                
                // Create the grid of buildings and streets
                for (let x = -gridSize; x <= gridSize; x++) {
                    for (let z = -gridSize; z <= gridSize; z++) {
                        // Position for this block
                        const posX = x * (blockSize + streetWidth);
                        const posZ = z * (blockSize + streetWidth);
                        
                        // Skip the center block (make it a park)
                        if (x === 0 && z === 0) {
                            this.createPark(posX, posZ, blockSize);
                            continue;
                        }
                        
                        // Create a block of buildings
                        this.createCityBlock(posX, posZ, blockSize);
                    }
                }
                
                // Create horizontal streets
                for (let x = -gridSize; x <= gridSize; x++) {
                    for (let z = -gridSize-1; z <= gridSize; z++) {
                        const posX = x * (blockSize + streetWidth);
                        const posZ = z * (blockSize + streetWidth) + blockSize/2 + streetWidth/2;
                        this.createRoad(posX, posZ, blockSize + streetWidth, streetWidth, true);
                    }
                }
                
                // Create vertical streets
                for (let x = -gridSize-1; x <= gridSize; x++) {
                    for (let z = -gridSize; z <= gridSize; z++) {
                        const posX = x * (blockSize + streetWidth) + blockSize/2 + streetWidth/2;
                        const posZ = z * (blockSize + streetWidth);
                        this.createRoad(posX, posZ, streetWidth, blockSize + streetWidth, false);
                    }
                }
                
                // Create intersections (simple crossroads)
                for (let x = -gridSize; x <= gridSize+1; x++) {
                    for (let z = -gridSize; z <= gridSize+1; z++) {
                        const posX = x * (blockSize + streetWidth) - blockSize/2 - streetWidth/2;
                        const posZ = z * (blockSize + streetWidth) - blockSize/2 - streetWidth/2;
                        this.createIntersection(posX, posZ, streetWidth);
                    }
                }
            }
            
            createCityBlock(x, z, size) {
                // Create a block of buildings
                const buildingsPerSide = 4;
                const buildingSize = size / buildingsPerSide;
                const padding = buildingSize * 0.1; // Space between buildings
                
                for (let bx = 0; bx < buildingsPerSide; bx++) {
                    for (let bz = 0; bz < buildingsPerSide; bz++) {
                        // Randomly skip some buildings to create variety
                        if (Math.random() < 0.3) continue;
                        
                        const buildingX = x - size/2 + bx * buildingSize + buildingSize/2;
                        const buildingZ = z - size/2 + bz * buildingSize + buildingSize/2;
                        
                        // Randomly determine building height
                        const height = 5 + Math.random() * 15;
                        
                        // Create building with reduced size for spacing
                        const actualSize = buildingSize - padding;
                        this.createBuilding(buildingX, buildingZ, actualSize, actualSize, height);
                    }
                }
            }
            
            createPark(x, z, size) {
                // Create a park with grass
                const parkGeometry = new THREE.PlaneGeometry(size, size);
                const parkMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x33aa33, // Green
                    roughness: 0.9
                });
                const park = new THREE.Mesh(parkGeometry, parkMaterial);
                park.rotation.x = degToRad(-90); // Rotate to be horizontal
                park.position.set(x, 0.01, z); // Slightly above ground to avoid z-fighting
                park.receiveShadow = true;
                this.scene.add(park);
                
                // Add some trees or decorations
                const numTrees = 12;
                for (let i = 0; i < numTrees; i++) {
                    const treeX = x - size/2 + Math.random() * size;
                    const treeZ = z - size/2 + Math.random() * size;
                    this.createTree(treeX, treeZ);
                }
            }
            
            createTree(x, z) {
                // Tree trunk (brown cylinder)
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.8, 3, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513, // Brown
                    roughness: 0.9
                });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(x, 1.5, z);
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                this.scene.add(trunk);
                
                // Tree top (green cone)
                const topGeometry = new THREE.ConeGeometry(3, 6, 8);
                const topMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x228B22, // Forest green
                    roughness: 0.8
                });
                const top = new THREE.Mesh(topGeometry, topMaterial);
                top.position.set(x, 6, z);
                top.castShadow = true;
                top.receiveShadow = true;
                this.scene.add(top);
            }
            
            createBuilding(x, z, width, depth, height) {
                // Create building geometry
                const geometry = new THREE.BoxGeometry(width, height, depth);
                
                // Random color for variety
                const colors = [0x999999, 0x888888, 0x777777, 0xaaaaaa, 0xcccccc];
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                const material = new THREE.MeshStandardMaterial({ 
                    color: color,
                    roughness: 0.7,
                    metalness: 0.2
                });
                
                const building = new THREE.Mesh(geometry, material);
                building.position.set(x, height/2, z);
                building.castShadow = true;
                building.receiveShadow = true;
                this.scene.add(building);
                
                // Add building to collidable objects array
                this.collidableObjects.push({
                    type: 'building',
                    mesh: building,
                    position: new THREE.Vector3(x, 0, z), // Ground level position for collision
                    width: width,
                    depth: depth,
                    height: height
                });
                
                // Add windows (simple texture or geometry)
                this.addBuildingWindows(building, width, depth, height);
                
                return building;
            }
            
            addBuildingWindows(building, width, depth, height) {
                // Simple window pattern using small boxes
                const windowSize = 0.8;
                const windowSpacing = 2;
                const windowsPerFloor = Math.max(1, Math.floor(width / windowSpacing));
                const floors = Math.max(1, Math.floor(height / windowSpacing));
                
                const windowMaterial = new THREE.MeshStandardMaterial({
                    color: 0x88ccff, // Light blue
                    emissive: 0x88ccff,
                    emissiveIntensity: 0.2,
                    roughness: 0.1,
                    metalness: 0.9
                });
                
                // Windows on front face
                for (let floor = 0; floor < floors; floor++) {
                    for (let w = 0; w < windowsPerFloor; w++) {
                        const windowGeometry = new THREE.BoxGeometry(windowSize, windowSize, 0.1);
                        const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
                        
                        const wx = -width/2 + w * windowSpacing + windowSpacing/2;
                        const wy = -height/2 + floor * windowSpacing + windowSpacing/2;
                        
                        windowMesh.position.set(wx, wy, depth/2 + 0.05);
                        building.add(windowMesh);
                        
                        // Add window on the back
                        const backWindow = windowMesh.clone();
                        backWindow.position.set(wx, wy, -depth/2 - 0.05);
                        backWindow.rotation.y = Math.PI;
                        building.add(backWindow);
                    }
                }
                
                // Windows on side faces
                const sideWindowsPerFloor = Math.max(1, Math.floor(depth / windowSpacing));
                
                for (let floor = 0; floor < floors; floor++) {
                    for (let w = 0; w < sideWindowsPerFloor; w++) {
                        const windowGeometry = new THREE.BoxGeometry(0.1, windowSize, windowSize);
                        const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
                        
                        const wz = -depth/2 + w * windowSpacing + windowSpacing/2;
                        const wy = -height/2 + floor * windowSpacing + windowSpacing/2;
                        
                        windowMesh.position.set(width/2 + 0.05, wy, wz);
                        building.add(windowMesh);
                        
                        // Add window on the opposite side
                        const leftWindow = windowMesh.clone();
                        leftWindow.position.set(-width/2 - 0.05, wy, wz);
                        leftWindow.rotation.y = Math.PI;
                        building.add(leftWindow);
                    }
                }
            }
            
            createRoad(x, z, width, depth, isHorizontal) {
                // Create road surface
                const roadGeometry = new THREE.PlaneGeometry(width, depth);
                const roadMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x444444, // Dark gray for asphalt
                    roughness: 0.9
                });
                const road = new THREE.Mesh(roadGeometry, roadMaterial);
                road.rotation.x = degToRad(-90); // Rotate to be horizontal
                road.position.set(x, 0.02, z); // Slightly above ground
                road.receiveShadow = true;
                this.scene.add(road);
                
                // Add yellow lines in the middle of the road
                const lineWidth = 0.5;
                const lineDepth = isHorizontal ? depth * 0.8 : width * 0.8;
                const lineGeometry = new THREE.PlaneGeometry(
                    isHorizontal ? lineWidth : lineDepth,
                    isHorizontal ? lineDepth : lineWidth
                );
                const lineMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffff00, // Yellow
                    roughness: 0.5
                });
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.rotation.x = degToRad(-90);
                line.position.set(x, 0.03, z); // Slightly above road
                line.receiveShadow = true;
                this.scene.add(line);
            }
            
            createIntersection(x, z, size) {
                // Create intersection (just a square of road)
                const intersectionGeometry = new THREE.PlaneGeometry(size, size);
                const intersectionMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x444444, // Dark gray for asphalt
                    roughness: 0.9
                });
                const intersection = new THREE.Mesh(intersectionGeometry, intersectionMaterial);
                intersection.rotation.x = degToRad(-90);
                intersection.position.set(x, 0.02, z); // Slightly above ground
                intersection.receiveShadow = true;
                this.scene.add(intersection);
                
                // Add zebra crossings
                this.addZebraCrossing(x, z, size);
            }
            
            addZebraCrossing(x, z, size) {
                // Create zebra crossing stripes
                const stripeCount = 4;
                const stripeWidth = 1;
                const stripeLength = size * 0.6;
                const gap = size / (stripeCount + 1);
                
                const stripeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff, // White
                    roughness: 0.5
                });
                
                // Horizontal stripes
                for (let i = 1; i <= stripeCount; i++) {
                    const stripeGeometry = new THREE.PlaneGeometry(stripeLength, stripeWidth);
                    const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                    stripe.rotation.x = degToRad(-90);
                    stripe.position.set(x, 0.03, z - size/2 + i * gap); // Slightly above road
                    stripe.receiveShadow = true;
                    this.scene.add(stripe);
                }
                
                // Vertical stripes
                for (let i = 1; i <= stripeCount; i++) {
                    const stripeGeometry = new THREE.PlaneGeometry(stripeWidth, stripeLength);
                    const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                    stripe.rotation.x = degToRad(-90);
                    stripe.position.set(x - size/2 + i * gap, 0.03, z); // Slightly above road
                    stripe.receiveShadow = true;
                    this.scene.add(stripe);
                }
            }
            
            createPlayerVehicle() {
                // Create a simple group to hold car parts
                this.player = new THREE.Group();
                this.player.position.set(0, 0.5, 0);
                this.scene.add(this.player);
                
                // Car dimensions - sporty profile
                const carWidth = 2.0;
                const carHeight = 0.4; // Very low profile for a sports car
                const carLength = 4.2;
                
                // Main body - low and sleek
                const bodyGeometry = new THREE.BoxGeometry(carWidth, carHeight, carLength);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000, // Bright red for sports car
                    roughness: 0.2,
                    metalness: 0.8
                });
                
                const carBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
                carBody.position.y = carHeight/2 + 0.1;
                carBody.castShadow = true;
                carBody.receiveShadow = true;
                this.player.add(carBody);
                
                // Add roof section (smaller than body for sporty look)
                const roofWidth = carWidth * 0.6;
                const roofHeight = 0.25;
                const roofLength = carLength * 0.45;
                
                const roofGeometry = new THREE.BoxGeometry(roofWidth, roofHeight, roofLength);
                const roofMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xdd0000, // Slightly darker red
                    roughness: 0.3,
                    metalness: 0.7
                });
                
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.y = carHeight + roofHeight/2 + 0.1;
                roof.position.z = -carLength * 0.05; // Slightly forward from center
                roof.castShadow = true;
                this.player.add(roof);
                
                // Windows (for visibility from top view)
                const windowMaterial = new THREE.MeshStandardMaterial({
                    color: 0x88ccff,
                    roughness: 0.1,
                    metalness: 0.9,
                    transparent: true,
                    opacity: 0.7
                });
                
                // Windshield
                const windshieldGeometry = new THREE.PlaneGeometry(roofWidth * 0.9, roofLength * 0.3);
                const windshield = new THREE.Mesh(windshieldGeometry, windowMaterial);
                windshield.rotation.x = degToRad(-90);
                windshield.position.set(0, carHeight + roofHeight + 0.02, -roofLength * 0.5);
                this.player.add(windshield);
                
                // Rear window
                const rearWindow = windshield.clone();
                rearWindow.position.z = roofLength * 0.4;
                this.player.add(rearWindow);
                
                // Side windows (will be visible from top)
                const sideWindowGeometry = new THREE.PlaneGeometry(roofLength * 0.8, roofHeight * 0.8);
                
                // Left side window
                const leftWindow = new THREE.Mesh(sideWindowGeometry, windowMaterial);
                leftWindow.rotation.y = degToRad(90);
                leftWindow.position.set(-roofWidth/2 - 0.01, carHeight + roofHeight/2 + 0.1, 0);
                this.player.add(leftWindow);
                
                // Right side window
                const rightWindow = leftWindow.clone();
                rightWindow.rotation.y = degToRad(-90);
                rightWindow.position.x = roofWidth/2 + 0.01;
                this.player.add(rightWindow);
                
                // Front detail (grill and bumper)
                const frontDetailGeometry = new THREE.BoxGeometry(carWidth * 0.9, carHeight * 0.5, carLength * 0.05);
                const frontDetailMaterial = new THREE.MeshStandardMaterial({
                    color: 0x111111,
                    roughness: 0.8
                });
                
                const frontDetail = new THREE.Mesh(frontDetailGeometry, frontDetailMaterial);
                frontDetail.position.set(0, carHeight * 0.3, -carLength/2 - 0.05);
                this.player.add(frontDetail);
                
                // Rear spoiler - important visual element for top-down view
                const spoilerWidth = carWidth * 0.8;
                const spoilerHeight = 0.12;
                const spoilerDepth = 0.3;
                
                const spoilerGeometry = new THREE.BoxGeometry(spoilerWidth, spoilerHeight, spoilerDepth);
                const spoilerMaterial = new THREE.MeshStandardMaterial({
                    color: 0x222222,
                    roughness: 0.5,
                    metalness: 0.6
                });
                
                const spoiler = new THREE.Mesh(spoilerGeometry, spoilerMaterial);
                spoiler.position.set(0, carHeight + roofHeight * 0.5, carLength/2 - spoilerDepth/2);
                this.player.add(spoiler);
                
                // Spoiler stands
                const standGeometry = new THREE.BoxGeometry(0.1, spoilerHeight * 2, spoilerDepth/2);
                const leftStand = new THREE.Mesh(standGeometry, spoilerMaterial);
                leftStand.position.set(-spoilerWidth/2 + 0.1, carHeight + spoilerHeight/2, carLength/2 - spoilerDepth/2);
                this.player.add(leftStand);
                
                const rightStand = leftStand.clone();
                rightStand.position.x = spoilerWidth/2 - 0.1;
                this.player.add(rightStand);
                
                // Headlights (clearly visible from top)
                const headlightGeometry = new THREE.BoxGeometry(carWidth * 0.2, carHeight * 0.3, 0.1);
                const headlightMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    emissive: 0xffffcc,
                    emissiveIntensity: 0.5
                });
                
                // Left headlight
                const leftHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
                leftHeadlight.position.set(-carWidth * 0.3, carHeight * 0.5, -carLength/2 - 0.06);
                this.player.add(leftHeadlight);
                
                // Right headlight
                const rightHeadlight = leftHeadlight.clone();
                rightHeadlight.position.x = carWidth * 0.3;
                this.player.add(rightHeadlight);
                
                // Add real headlight spotlights
                this.addHeadlightSpotlights(leftHeadlight, rightHeadlight, carLength);
                
                // Taillights (very visible from top)
                const taillightGeometry = new THREE.BoxGeometry(carWidth * 0.2, carHeight * 0.3, 0.1);
                const taillightMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.5
                });
                
                // Left taillight
                const leftTaillight = new THREE.Mesh(taillightGeometry, taillightMaterial);
                leftTaillight.position.set(-carWidth * 0.3, carHeight * 0.5, carLength/2 + 0.06);
                this.player.add(leftTaillight);
                
                // Right taillight
                const rightTaillight = leftTaillight.clone();
                rightTaillight.position.x = carWidth * 0.3;
                this.player.add(rightTaillight);
                
                // Add real taillight point lights
                this.addTaillightPointLights(leftTaillight, rightTaillight);
                
                // Wheels - make them more visible from top-down view
                this.addSimpleSportyWheels(carWidth, carLength);
                
                return this.player;
            }
            
            addSimpleSportyWheels(carWidth, carLength) {
                const wheelRadius = 0.4;
                const wheelThickness = 0.2;
                
                // Create wheel geometry with more detail visible from top
                const wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelThickness, 16);
                const wheelMaterial = new THREE.MeshStandardMaterial({
                    color: 0x222222,
                    roughness: 0.9
                });
                
                // Create hubcap geometry
                const hubcapGeometry = new THREE.CylinderGeometry(wheelRadius * 0.6, wheelRadius * 0.6, wheelThickness + 0.02, 5);
                const hubcapMaterial = new THREE.MeshStandardMaterial({
                    color: 0xC0C0C0, // Silver
                    roughness: 0.3,
                    metalness: 0.8
                });
                
                // Function to create a wheel at a specific position
                const createWheel = (x, z) => {
                    const wheelGroup = new THREE.Group();
                    
                    // Tire
                    const tire = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    tire.rotation.z = Math.PI / 2; // Correct orientation
                    tire.castShadow = true;
                    wheelGroup.add(tire);
                    
                    // Hubcap
                    const hubcap = new THREE.Mesh(hubcapGeometry, hubcapMaterial);
                    hubcap.rotation.z = Math.PI / 2;
                    // Add a small offset to prevent z-fighting
                    hubcap.position.set(0, 0.01, 0);
                    wheelGroup.add(hubcap);
                    
                    // Position wheel on car
                    wheelGroup.position.set(x, wheelRadius, z);
                    this.player.add(wheelGroup);
                    
                    return wheelGroup;
                };
                
                // Position wheels relative to car body
                const xOffset = carWidth/2 * 0.9; // Slightly inset from edge
                const zOffset = carLength/3;      // Position at 1/3 and 2/3 of car length
                
                createWheel(-xOffset, -zOffset);  // Front left
                createWheel(xOffset, -zOffset);   // Front right
                createWheel(-xOffset, zOffset);   // Rear left
                createWheel(xOffset, zOffset);    // Rear right
            }
            
            toggleVehicle() {
                if (this.isInVehicle) {
                    // Exit vehicle
                    this.createPedestrian();
                    this.player.visible = true; // Keep vehicle visible
                    this.lastVehiclePosition.copy(this.player.position);
                    this.lastVehicleRotation = this.player.rotation.y;
                    // Reset vehicle velocity when exiting
                    this.playerVelocity = 0;
                    // Set camera height for pedestrian view
                    this.targetCameraHeight = 25;
                } else {
                    // Check distance to vehicle
                    const distance = this.pedestrian.position.distanceTo(this.player.position);
                    if (distance < 5) { // Can only enter if close to vehicle
                        // Enter vehicle
                        this.scene.remove(this.pedestrian);
                        this.pedestrian = null;
                        // Set camera height for vehicle view
                        this.targetCameraHeight = this.CAMERA_HEIGHT;
                    } else {
                        return; // Too far from vehicle
                    }
                }
                
                this.isInVehicle = !this.isInVehicle;
                document.getElementById('info').textContent = "GTA 2 Clone - 3D Version";
            }
            
            createPedestrian() {
                // Create a group to hold all pedestrian parts
                this.pedestrian = new THREE.Group();
                
                // Colors
                const skinColor = 0xffdbac;
                const shirtColor = 0x3366cc; // Blue shirt
                const pantsColor = 0x333333; // Dark gray pants
                const shoeColor = 0x111111; // Black shoes
                
                // Materials
                const skinMaterial = new THREE.MeshStandardMaterial({ 
                    color: skinColor,
                    roughness: 0.7
                });
                const shirtMaterial = new THREE.MeshStandardMaterial({ 
                    color: shirtColor,
                    roughness: 0.8
                });
                const pantsMaterial = new THREE.MeshStandardMaterial({ 
                    color: pantsColor,
                    roughness: 0.8
                });
                const shoeMaterial = new THREE.MeshStandardMaterial({ 
                    color: shoeColor,
                    roughness: 0.9
                });
                
                // Head (sphere)
                const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const head = new THREE.Mesh(headGeometry, skinMaterial);
                head.position.y = 1.6;
                head.castShadow = true;
                this.pedestrian.add(head);
                
                // Torso (slightly tapered box)
                const torsoGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.3);
                const torso = new THREE.Mesh(torsoGeometry, shirtMaterial);
                torso.position.y = 1.1;
                torso.castShadow = true;
                this.pedestrian.add(torso);
                
                // Arms
                this.addLimb(this.pedestrian, 0.15, 0.5, 0.15, 0.3, 1.1, 0, shirtMaterial, true);  // Left arm
                this.addLimb(this.pedestrian, -0.15, 0.5, 0.15, 0.3, 1.1, 0, shirtMaterial, true); // Right arm
                
                // Legs
                this.addLimb(this.pedestrian, 0.2, 0, 0, 0.15, 0.6, 0.15, pantsMaterial, false);  // Left leg
                this.addLimb(this.pedestrian, -0.2, 0, 0, 0.15, 0.6, 0.15, pantsMaterial, false); // Right leg
                
                // Hands
                const handGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const leftHand = new THREE.Mesh(handGeometry, skinMaterial);
                leftHand.position.set(0.3, 0.85, 0);
                this.pedestrian.add(leftHand);
                
                const rightHand = new THREE.Mesh(handGeometry, skinMaterial);
                rightHand.position.set(-0.3, 0.85, 0);
                this.pedestrian.add(rightHand);
                
                // Feet (shoes)
                const shoeGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.3);
                const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
                leftShoe.position.set(0.2, 0.05, 0.05);
                this.pedestrian.add(leftShoe);
                
                const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
                rightShoe.position.set(-0.2, 0.05, 0.05);
                this.pedestrian.add(rightShoe);
                
                // Position pedestrian next to vehicle with slight offset
                const offset = new THREE.Vector3(
                    Math.sin(this.player.rotation.y) * 3,
                    0,
                    Math.cos(this.player.rotation.y) * 3
                );
                
                this.pedestrian.position.copy(this.player.position).add(offset);
                this.pedestrian.position.y = 0; // Set to ground level
                this.pedestrian.castShadow = true;
                this.pedestrian.receiveShadow = true;
                this.scene.add(this.pedestrian);
                
                return this.pedestrian;
            }
            
            addLimb(parentGroup, x, y, z, width, height, depth, material, isArm) {
                // Create a limb (arm or leg)
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const limb = new THREE.Mesh(geometry, material);
                
                // For arms, center is near shoulder
                // For legs, center is near hip
                const centerY = isArm ? height * 0.3 : height * 0.4;
                
                limb.position.set(x, y + centerY, z);
                limb.castShadow = true;
                parentGroup.add(limb);
                
                return limb;
            }
            
            toggleLights() {
                this.lightsOn = !this.lightsOn;
                if (this.lightsOn) {
                    // Turn on headlights and taillights
                    this.headlights.forEach(light => {
                        if (light instanceof THREE.Light) {
                            light.intensity = 2.0; // Increased from 1.3 to 2.0 for stronger illumination
                        } else if (light.flare) {
                            light.flare.material.opacity = 0.8;
                        }
                    });
                    this.taillights.forEach(light => {
                        if (light instanceof THREE.Light) {
                            light.intensity = 0.5; // Dimmer when not braking
                        } else if (light.flare) {
                            light.flare.material.opacity = 0.6;
                        }
                    });
                } else {
                    // Turn off headlights and taillights
                    this.headlights.forEach(light => {
                        if (light instanceof THREE.Light) {
                            light.intensity = 0;
                        } else if (light.flare) {
                            light.flare.material.opacity = 0;
                        }
                    });
                    this.taillights.forEach(light => {
                        if (light instanceof THREE.Light) {
                            light.intensity = 0;
                        } else if (light.flare) {
                            light.flare.material.opacity = 0;
                        }
                    });
                }
                
                // Update info text to show light status
                document.getElementById('info').textContent = this.lightsOn ? 
                    "GTA 2 Clone - Lights ON (Press L to toggle)" : 
                    "GTA 2 Clone - Lights OFF (Press L to toggle)";
            }
            
            updateBrakeLights(isBraking) {
                // Only update if lights are on
                if (!this.lightsOn) return;
                
                this.taillights.forEach(light => {
                    if (light instanceof THREE.Light) {
                        // Brighter when braking
                        light.intensity = isBraking ? 1.5 : 0.5;
                    } else if (light.flare) {
                        // Larger flare when braking
                        light.flare.material.opacity = isBraking ? 1.0 : 0.6;
                        light.flare.scale.set(
                            isBraking ? 1.5 : 1.0,
                            isBraking ? 1.5 : 1.0,
                            1.0
                        );
                    }
                });
            }
            
            addHeadlightSpotlights(leftHeadlight, rightHeadlight, carLength) {
                // Create spotlight for left headlight with improved parameters
                const leftSpotlight = new THREE.SpotLight(
                    0xffffee,     // color
                    0,            // intensity (will be set when toggled on)
                    60,           // distance (increased from 50)
                    Math.PI / 4,  // angle (widened from Math.PI/5)
                    0.8,          // penumbra (increased from 0.5 for softer edges)
                    1             // decay (reduced from 2 for better distance coverage)
                );
                leftSpotlight.position.copy(leftHeadlight.position);
                // Position slightly forward and higher from the headlight mesh
                leftSpotlight.position.z -= 0.1;
                leftSpotlight.position.y += 0.2; // Raise slightly for better angle to ground
                
                // Target for the spotlight - positioned to hit the ground ahead of the car
                const leftTarget = new THREE.Object3D();
                leftTarget.position.set(
                    leftSpotlight.position.x, 
                    -0.5,         // Less extreme downward angle to illuminate more of the road
                    leftSpotlight.position.z - 15 // 15 units ahead to illuminate more road
                );
                this.player.add(leftTarget);
                leftSpotlight.target = leftTarget;
                
                // Improved shadow settings for better ground visibility
                leftSpotlight.castShadow = true;
                leftSpotlight.shadow.mapSize.width = 1024;  // Increased from 512
                leftSpotlight.shadow.mapSize.height = 1024; // Increased from 512
                leftSpotlight.shadow.camera.near = 0.1;     // Closer near plane
                leftSpotlight.shadow.camera.far = 60;       // Match light distance
                leftSpotlight.shadow.bias = -0.0005;        // Reduce shadow acne
                
                // Create spotlight for right headlight (similar to left)
                const rightSpotlight = new THREE.SpotLight(
                    0xffffee,     // color
                    0,            // intensity (will be set when toggled on)
                    60,           // distance
                    Math.PI / 4,  // angle
                    0.8,          // penumbra
                    1             // decay
                );
                rightSpotlight.position.copy(rightHeadlight.position);
                rightSpotlight.position.z -= 0.1;
                rightSpotlight.position.y += 0.2; // Raise slightly
                
                const rightTarget = new THREE.Object3D();
                rightTarget.position.set(
                    rightSpotlight.position.x,
                    -2, // Point more downward toward ground (was 0)
                    rightSpotlight.position.z - 10 // 10 units ahead (was 20 - shorter to point more down)
                );
                this.player.add(rightTarget);
                rightSpotlight.target = rightTarget;
                
                // Configure shadows for both spotlights
                leftSpotlight.castShadow = true;
                rightSpotlight.castShadow = true;
                
                // Optimize shadow map settings
                leftSpotlight.shadow.mapSize.width = 512;
                leftSpotlight.shadow.mapSize.height = 512;
                rightSpotlight.shadow.mapSize.width = 512;
                rightSpotlight.shadow.mapSize.height = 512;
                
                // Add light to car
                this.player.add(leftSpotlight);
                this.player.add(rightSpotlight);
                
                // Store light references for toggling
                this.headlights.push(leftSpotlight, rightSpotlight);
                
                // Start with lights off
                leftSpotlight.intensity = 0;
                rightSpotlight.intensity = 0;
                
                // Add lens flare effect
                this.addLensFlare(leftHeadlight.position, 0xffffee);
                this.addLensFlare(rightHeadlight.position, 0xffffee);
            }
            
            addTaillightPointLights(leftTaillight, rightTaillight) {
                // Tail lights are red point lights
                const leftLight = new THREE.PointLight(0xff0000, 0, 20, 2);
                leftLight.position.copy(leftTaillight.position);
                // Position slightly behind taillight mesh
                leftLight.position.z += 0.1;
                
                const rightLight = new THREE.PointLight(0xff0000, 0, 20, 2);
                rightLight.position.copy(rightTaillight.position);
                rightLight.position.z += 0.1;
                
                // No shadows for taillights to save performance
                leftLight.castShadow = false;
                rightLight.castShadow = false;
                
                // Add to car
                this.player.add(leftLight);
                this.player.add(rightLight);
                
                // Store references for toggling
                this.taillights.push(leftLight, rightLight);
                
                // Start with lights off
                leftLight.intensity = 0;
                rightLight.intensity = 0;
                
                // Add smaller lens flare for taillights
                this.addLensFlare(leftTaillight.position, 0xff0000, 0.5);
                this.addLensFlare(rightTaillight.position, 0xff0000, 0.5);
            }
            
            addLensFlare(position, color, scale = 1.0) {
                // Create a simple lens flare effect using a sprite
                const textureLoader = new THREE.TextureLoader();
                const flareTexture = textureLoader.load('https://threejs.org/examples/textures/lensflare/lensflare0.png');
                
                const flareMaterial = new THREE.SpriteMaterial({
                    map: flareTexture,
                    color: color,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    opacity: 0 // Start invisible until lights are turned on
                });
                
                const flare = new THREE.Sprite(flareMaterial);
                flare.position.copy(position);
                flare.scale.set(2 * scale, 2 * scale, 1 * scale);
                
                this.player.add(flare);
                
                // Store reference to the flare in the corresponding light
                if (color === 0xff0000) {
                    this.taillights.push({ flare: flare });
                } else {
                    this.headlights.push({ flare: flare });
                }
            }
            
            applyDriftPhysics(deltaTime) {
                // Gradually recover from drift when handbrake is released
                if (!this.handbrakeActive) {
                    // Restore traction gradually
                    this.rearTractionFactor = Math.min(1.0, this.rearTractionFactor + deltaTime * 2.0);
                    
                    // Dampen angular velocity (rotational momentum)
                    this.angularVelocity *= (1.0 - Math.min(1.0, deltaTime * 3.0));
                    
                    // Dampen lateral velocity more aggressively when not drifting
                    this.lateralVelocity *= (1.0 - Math.min(1.0, deltaTime * 5.0));
                } else {
                    // When handbrake is active, lateral velocity persists more
                    this.lateralVelocity *= (1.0 - Math.min(1.0, deltaTime * 0.5));
                    
                    // Angular velocity decreases more slowly
                    this.angularVelocity *= (1.0 - Math.min(1.0, deltaTime * 1.0));
                }
                
                // Apply tire smoke effects when drifting hard
                if (this.handbrakeActive && Math.abs(this.lateralVelocity) > 10 && Math.abs(this.playerVelocity) > 10) {
                    // Create tire smoke at rear wheels
                    this.createDriftSmoke();
                }
            }
            
            createDriftSmoke() {
                // Only create drift smoke occasionally to prevent overwhelming effects
                if (Math.random() < 0.2) {
                    // Get car's current rotation
                    const carAngle = this.player.rotation.y;
                    
                    // Calculate wheel positions (rear wheels)
                    const wheelBase = 2.0; // Distance between front and rear axles
                    const trackWidth = 1.6; // Distance between left and right wheels
                    
                    // Rear wheel positions relative to car center
                    const rearWheelZ = wheelBase / 2;
                    
                    // Calculate world positions for rear wheels
                    const leftRearWheelPos = new THREE.Vector3(
                        this.player.position.x - Math.sin(carAngle) * rearWheelZ - Math.sin(carAngle + Math.PI/2) * trackWidth/2,
                        0.3, // Slightly above ground
                        this.player.position.z - Math.cos(carAngle) * rearWheelZ - Math.cos(carAngle + Math.PI/2) * trackWidth/2
                    );
                    
                    const rightRearWheelPos = new THREE.Vector3(
                        this.player.position.x - Math.sin(carAngle) * rearWheelZ + Math.sin(carAngle + Math.PI/2) * trackWidth/2,
                        0.3, // Slightly above ground
                        this.player.position.z - Math.cos(carAngle) * rearWheelZ + Math.cos(carAngle + Math.PI/2) * trackWidth/2
                    );
                    
                    // Create smoke effect at each rear wheel
                    this.createSmokeParticles(leftRearWheelPos);
                    this.createSmokeParticles(rightRearWheelPos);
                }
            }
            
            createSmokeParticles(position) {
                // Parameters for smoke effect
                const smokeCount = 10 + Math.floor(Math.random() * 10);
                const smokeGroup = new THREE.Group();
                smokeGroup.position.copy(position);
                this.scene.add(smokeGroup);
                
                // Create individual smoke particles
                for (let i = 0; i < smokeCount; i++) {
                    // Random smoke direction in a circle
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 5;
                    
                    // Create larger particles for smoke
                    const smokeSize = 0.3 + Math.random() * 0.5;
                    const smokeGeometry = new THREE.PlaneGeometry(smokeSize, smokeSize);
                    
                    // Use white smoke for tire burn
                    const smokeMaterial = new THREE.MeshBasicMaterial({
                        color: 0xeeeeee,
                        transparent: true, 
                        opacity: 0.3 + Math.random() * 0.3
                    });
                    
                    const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
                    smoke.rotation.x = degToRad(-90); // Make it parallel to ground
                    smoke.castShadow = false;
                    smoke.receiveShadow = false;
                    
                    // Add to group
                    smokeGroup.add(smoke);
                    
                    // Random direction and velocity
                    smoke.userData = {
                        velocity: new THREE.Vector3(
                            Math.cos(angle) * speed,
                            0.8 + Math.random() * 2, // Upward velocity
                            Math.sin(angle) * speed
                        ),
                        rotation: Math.random() * 0.1,
                        created: Date.now(),
                        fadeTime: 1000 + Math.random() * 1000, // 1-2 seconds lifetime
                        size: smokeSize
                    };
                }
                
                // Track this smoke effect
                this.currentSparks.push({
                    group: smokeGroup,
                    created: Date.now(),
                    isSmoke: true
                });
            }
            
            createSkidmarks() {
                // Only create skidmarks when handbrake is active or drifting significantly
                if (!this.handbrakeActive && Math.abs(this.driftAngle) < 0.2) {
                    this.activeSkidmarks = false;
                    return;
                }
                
                const now = Date.now();
                const speedFactor = Math.abs(this.playerVelocity);
                
                // Skip at very low speeds
                if (speedFactor < 3) return;
                
                this.activeSkidmarks = true;
                
                // Throttle creation rate for performance - higher speeds get more frequent updates
                let interval = 100; // Base interval in ms
                if (speedFactor > 40) {
                    interval = 50;
                } else if (speedFactor > 20) {
                    interval = 70;
                }
                
                if (now - this.lastSkidmarkTime < interval) return;
                this.lastSkidmarkTime = now;
                
                // Calculate wheel positions
                const carAngle = this.player.rotation.y;
                const wheelBase = 2.0; // Distance between front and rear axles
                const trackWidth = 1.6; // Distance between left and right wheels
                
                // Rear wheel positions relative to car center
                const rearWheelZ = wheelBase / 2;
                
                // Calculate world positions for rear wheels
                const leftRearWheelPos = new THREE.Vector3(
                    this.player.position.x - Math.sin(carAngle) * rearWheelZ - Math.sin(carAngle + Math.PI/2) * trackWidth/2,
                    0.05, // Slightly above ground to prevent z-fighting
                    this.player.position.z - Math.cos(carAngle) * rearWheelZ - Math.cos(carAngle + Math.PI/2) * trackWidth/2
                );
                
                const rightRearWheelPos = new THREE.Vector3(
                    this.player.position.x - Math.sin(carAngle) * rearWheelZ + Math.sin(carAngle + Math.PI/2) * trackWidth/2,
                    0.05, // Slightly above ground
                    this.player.position.z - Math.cos(carAngle) * rearWheelZ + Math.cos(carAngle + Math.PI/2) * trackWidth/2
                );
                
                // Create skidmarks for left rear wheel
                if (this.lastWheelPositions.leftRear.length() > 0) {
                    const distanceMoved = leftRearWheelPos.distanceTo(this.lastWheelPositions.leftRear);
                    
                    if (distanceMoved > this.minSegmentLength) {
                        this.addSkidmarkSegment(this.lastWheelPositions.leftRear, leftRearWheelPos, speedFactor);
                        this.lastWheelPositions.leftRear.copy(leftRearWheelPos);
                    }
                } else {
                    // First time, just store the position
                    this.lastWheelPositions.leftRear.copy(leftRearWheelPos);
                }
                
                // Create skidmarks for right rear wheel
                if (this.lastWheelPositions.rightRear.length() > 0) {
                    const distanceMoved = rightRearWheelPos.distanceTo(this.lastWheelPositions.rightRear);
                    
                    if (distanceMoved > this.minSegmentLength) {
                        this.addSkidmarkSegment(this.lastWheelPositions.rightRear, rightRearWheelPos, speedFactor);
                        this.lastWheelPositions.rightRear.copy(rightRearWheelPos);
                    }
                } else {
                    // First time, just store the position
                    this.lastWheelPositions.rightRear.copy(rightRearWheelPos);
                }
                
                // Ensure skidmark sound is playing
                this.playHandbrakeSound();
            }
            
            addSkidmarkSegment(startPos, endPos, speedFactor) {
                // Calculate segment properties
                const segmentLength = startPos.distanceTo(endPos);
                const segmentWidth = 0.25; // Thinner width for two-track skidmarks
                
                // Calculate the direction from start to end
                const direction = new THREE.Vector3().subVectors(endPos, startPos).normalize();
                
                // Calculate the perpendicular direction (for width)
                const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x);
                
                // Create a custom geometry for the skidmark segment
                const geometry = new THREE.BufferGeometry();
                
                // Define the four corners of the segment
                const startLeft = new THREE.Vector3().copy(startPos).addScaledVector(perpendicular, segmentWidth/2);
                const startRight = new THREE.Vector3().copy(startPos).addScaledVector(perpendicular, -segmentWidth/2);
                const endLeft = new THREE.Vector3().copy(endPos).addScaledVector(perpendicular, segmentWidth/2);
                const endRight = new THREE.Vector3().copy(endPos).addScaledVector(perpendicular, -segmentWidth/2);
                
                // Create vertices array
                const vertices = new Float32Array([
                    // First triangle
                    startLeft.x, startLeft.y, startLeft.z,
                    endLeft.x, endLeft.y, endLeft.z,
                    startRight.x, startRight.y, startRight.z,
                    
                    // Second triangle
                    endLeft.x, endLeft.y, endLeft.z,
                    endRight.x, endRight.y, endRight.z,
                    startRight.x, startRight.y, startRight.z
                ]);
                
                // Set the vertices of the geometry
                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                
                // Create the mesh
                const segment = new THREE.Mesh(geometry, this.skidmarkMaterial);
                
                // Add to scene
                this.scene.add(segment);
                
                // Track the skidmark and manage the maximum number
                this.skidmarks.push({
                    mesh: segment,
                    created: Date.now(),
                    opacity: 0.95
                });
                
                // Remove oldest skidmark if we've exceeded the maximum
                if (this.skidmarks.length > this.maxSkidmarks) {
                    const oldest = this.skidmarks.shift();
                    this.scene.remove(oldest.mesh);
                }
            }
            
            updateSkidmarks(deltaTime) {
                const now = Date.now();
                
                // Update opacity of skidmarks - they fade out over time
                for (let i = this.skidmarks.length - 1; i >= 0; i--) {
                    const skidmark = this.skidmarks[i];
                    const age = (now - skidmark.created) / 1000; // Age in seconds
                    
                    // Skidmarks start fading after 5 seconds and disappear after 30 seconds
                    if (age > 30) {
                        this.scene.remove(skidmark.mesh);
                        this.skidmarks.splice(i, 1);
                        continue;
                    }
                    
                    // Start fading after 5 seconds
                    if (age > 5) {
                        const fadeProgress = (age - 5) / 25; // 0-1 over 25 seconds
                        const newOpacity = 0.9 * (1 - fadeProgress);
                        skidmark.mesh.material.opacity = newOpacity;
                    }
                }
            }
            
            performPhysicsUpdate() {
                // Skip if not in vehicle
                if (!this.isInVehicle) return;
                
                // Movement and steering inputs
                const accelerating = (this.keys['w'] || this.keys['arrowup']) && !this.keys['s'] && !this.keys['arrowdown'];
                const braking = (this.keys['s'] || this.keys['arrowdown']) && !this.keys['w'] && !this.keys['arrowup'];
                const steeringLeft = this.keys['a'] || this.keys['arrowleft'];
                const steeringRight = this.keys['d'] || this.keys['arrowright'];
                
                // Calculate steering angle
                let steeringAngle = 0;
                if (steeringLeft) steeringAngle = this.maxSteeringAngle;
                if (steeringRight) steeringAngle = -this.maxSteeringAngle;
                
                // Speed-sensitive steering
                const speedFactor = Math.min(Math.abs(this.playerVelocity) / 40, 1);
                // At high speeds, steering becomes less responsive
                steeringAngle *= (1 - 0.4 * speedFactor); // Reduced sensitivity reduction
                
                // Apply acceleration and braking
                if (accelerating) {
                    // Add acceleration proportional to current gear ratio
                    const accelerationForce = this.currentGear.acceleration * this.deltaTime;
                    this.playerVelocity += accelerationForce;
                    
                    // Counter-steer helps stabilize during drift but don't overdo it
                    if (this.handbrakeActive && Math.abs(this.driftAngle) > 0.3) {
                        // Apply some corrective force based on drift angle, but keep it subtle
                        this.angularVelocity -= this.driftAngle * 0.2 * this.deltaTime;
                    }
                } else if (braking) {
                    // Apply braking force
                    const brakingForce = 35 * this.deltaTime;
                    
                    if (this.playerVelocity > 0) {
                        this.playerVelocity = Math.max(0, this.playerVelocity - brakingForce);
                    } else {
                        this.playerVelocity = Math.min(0, this.playerVelocity + brakingForce);
                    }
                }
                
                // Apply automatic drag/rolling resistance (always slows down the car)
                const dragFactor = 3; // Base rolling resistance
                const drag = dragFactor * this.deltaTime;
                
                if (Math.abs(this.playerVelocity) > drag) {
                    this.playerVelocity -= Math.sign(this.playerVelocity) * drag;
                } else {
                    this.playerVelocity = 0;
                }
                
                // Maximum speed clamping
                this.playerVelocity = Math.min(this.playerVelocity, this.currentGear.maxSpeed);
                this.playerVelocity = Math.max(this.playerVelocity, -this.reverseMaxSpeed);
                
                // Front-wheel steering effect - front wheels maintain grip
                if (Math.abs(this.playerVelocity) > 1) {
                    // Calculate the front wheel steering effect based on speed
                    const steeringEffect = steeringAngle * (Math.abs(this.playerVelocity) * 0.02);
                    
                    // For realistic drifting, modify how steering affects the car when handbrake is active
                    if (this.handbrakeActive) {
                        // When handbrake is active, front wheels still steer but with reduced effect
                        // This simulates front wheels fighting against the sliding rear
                        this.angularVelocity += steeringEffect * this.deltaTime * 1.8;
                        
                        // Apply drift physics - powerful rotational and lateral forces
                        if (Math.abs(steeringAngle) > 0.01) {
                            // Direction of the turn
                            const turnDirection = Math.sign(steeringAngle);
                            
                            // The key physics for proper drifting with rear swing:
                            // 1. Strong continuous rotational force in the steering direction
                            // This makes the car keep rotating throughout the drift
                            const rotationForce = turnDirection * Math.abs(this.playerVelocity) * 0.03;
                            this.angularVelocity += rotationForce * this.deltaTime * 2;
                            
                            // 2. Continuous lateral force opposite to the turn direction
                            // This pushes the rear outward while the front continues in steering direction
                            const lateralForce = turnDirection * Math.abs(this.playerVelocity) * 0.03;
                            this.lateralVelocity -= lateralForce * this.deltaTime * 6;
                        }
                    } else {
                        // Normal steering - standard effect
                        this.angularVelocity += steeringEffect * this.deltaTime * 2.5;
                    }
                }
                
                // Apply traction - critical for drift behavior
                // Front wheels maintain high grip regardless of handbrake
                let currentFrontTraction = this.frontTractionFactor;
                let currentRearTraction = this.defaultRearTraction;
                
                // Very low rear traction when handbrake is active
                if (this.handbrakeActive) {
                    currentRearTraction = this.rearTractionFactor;
                } else if (this.rearTractionFactor < this.defaultRearTraction) {
                    // Gradually restore traction after handbrake is released
                    this.rearTractionFactor += this.deltaTime * 1.5;
                    this.rearTractionFactor = Math.min(this.rearTractionFactor, this.defaultRearTraction);
                    currentRearTraction = this.rearTractionFactor;
                }
                
                // Apply separate traction to front and rear
                // This is key: front maintains grip, rear loses grip
                if (this.handbrakeActive) {
                    // When handbrake is active, lateral velocity is affected differently by front/rear traction
                    // Front wheels try to grip and go in the direction they're pointing
                    // Rear wheels slide freely
                    // This weighted traction model is crucial for proper drifting
                    
                    // Rear-biased traction calculation (mostly influenced by rear wheels)
                    const rearBiasedTraction = Math.pow(currentRearTraction, this.deltaTime);
                    // Front-biased traction calculation (mostly influenced by front wheels)
                    const frontBiasedTraction = Math.pow(currentFrontTraction, this.deltaTime);
                    
                    // Overall lateral traction is biased toward rear (70% rear, 30% front)
                    // This means rear wheels have more influence during handbrake
                    const driftTraction = (rearBiasedTraction * 0.7) + (frontBiasedTraction * 0.3);
                    this.lateralVelocity *= driftTraction;
                } else {
                    // Normal driving - standard traction model
                    const normalTraction = Math.pow((currentFrontTraction + currentRearTraction) / 2, this.deltaTime);
                    this.lateralVelocity *= normalTraction;
                }
                
                // Different angular drag during handbrake for better rotation
                // Higher value means more rotation is preserved during drift
                const angularDragFactor = this.handbrakeActive ? 0.97 : 0.85;
                this.angularVelocity *= Math.pow(angularDragFactor, this.deltaTime);
                
                // Calculate car direction vector
                const carDirection = new THREE.Vector3(
                    Math.sin(this.player.rotation.y),
                    0,
                    Math.cos(this.player.rotation.y)
                );
                
                // Calculate lateral direction (perpendicular to car direction)
                const lateralDirection = new THREE.Vector3(
                    carDirection.z,
                    0,
                    -carDirection.x
                );
                
                // Update position based on forward and lateral velocities
                this.player.position.x += carDirection.x * this.playerVelocity * this.deltaTime;
                this.player.position.z += carDirection.z * this.playerVelocity * this.deltaTime;
                
                this.player.position.x += lateralDirection.x * this.lateralVelocity * this.deltaTime;
                this.player.position.z += lateralDirection.z * this.lateralVelocity * this.deltaTime;
                
                // Update rotation based on angular velocity
                this.player.rotation.y += this.angularVelocity * this.deltaTime;
                
                // Calculate drift angle (angle between velocity and car direction)
                // This is used for visual effects and gameplay feedback
                const velocityDirection = new THREE.Vector3(
                    carDirection.x * this.playerVelocity + lateralDirection.x * this.lateralVelocity,
                    0,
                    carDirection.z * this.playerVelocity + lateralDirection.z * this.lateralVelocity
                ).normalize();
                
                if (velocityDirection.length() > 0.1) {
                    const dot = carDirection.dot(velocityDirection);
                    const det = carDirection.x * velocityDirection.z - carDirection.z * velocityDirection.x;
                    this.driftAngle = Math.atan2(det, dot);
                } else {
                    this.driftAngle = 0;
                }
                
                // Car tilt effect based on lateral velocity and turning
                // During drift, car should lean away from the turn
                const tiltAmount = 0.15; // Maximum tilt in radians
                
                // Tilt based on lateral velocity and angular velocity
                // This creates the visual effect of weight transfer
                const lateralTilt = this.lateralVelocity * 0.3;
                const angularTilt = this.angularVelocity * 0.8;
                
                // Apply tilt for visual effect - combined effect gives realistic lean
                this.player.rotation.z = Math.max(-tiltAmount, Math.min(tiltAmount, lateralTilt + angularTilt));
                
                // Update camera to follow the car
                this.updateCamera();
                
                // Check for skidmarks
                this.createSkidmarks();
                
                // Collision detection with buildings and obstacles
                this.checkCollisions();
                
                // Emission of dust/dirt particles when drifting
                this.checkParticles();
                
                // Update sound effects based on speed and driving conditions
                this.updateSounds();
            }
        }
        
        // Initialize game when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Starting GTA 2 Clone 3D...');
            const game = new Game();
        });
    </script>
</body>
</html> 